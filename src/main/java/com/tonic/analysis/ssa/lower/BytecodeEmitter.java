package com.tonic.analysis.ssa.lower;

import com.tonic.analysis.ssa.cfg.IRBlock;
import com.tonic.analysis.ssa.cfg.IRMethod;
import com.tonic.analysis.ssa.ir.*;
import com.tonic.analysis.ssa.type.*;
import com.tonic.analysis.ssa.value.*;
import com.tonic.parser.ConstPool;
import com.tonic.type.AccessFlags;
import com.tonic.utill.Opcode;
import lombok.Getter;

import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.util.*;

/**
 * Emits JVM bytecode from IR instructions.
 */
@Getter
public class BytecodeEmitter {

    private final IRMethod method;
    private final ConstPool constPool;
    private final RegisterAllocator regAlloc;
    private final StackScheduler scheduler;

    private ByteArrayOutputStream bytecode;
    private DataOutputStream dos;
    private Map<IRBlock, Integer> blockOffsets;
    private List<PendingJump> pendingJumps;
    private int currentOffset;

    private Set<SSAValue> stackResidentValues;

    // For fall-through optimization
    private IRBlock nextBlock;

    /**
     * Creates a new bytecode emitter.
     *
     * @param method the IR method to emit
     * @param constPool the constant pool
     * @param regAlloc the register allocator
     * @param scheduler the stack scheduler
     */
    public BytecodeEmitter(IRMethod method, ConstPool constPool, RegisterAllocator regAlloc, StackScheduler scheduler) {
        this.method = method;
        this.constPool = constPool;
        this.regAlloc = regAlloc;
        this.scheduler = scheduler;
        this.blockOffsets = new HashMap<>();
        this.pendingJumps = new ArrayList<>();
        this.stackResidentValues = new HashSet<>();
    }

    /**
     * Emits bytecode for the IR method.
     *
     * @return the generated bytecode
     */
    public byte[] emit() {
        bytecode = new ByteArrayOutputStream();
        dos = new DataOutputStream(bytecode);
        currentOffset = 0;

        analyzeStackResidentValues();

        try {
            List<IRBlock> orderedBlocks = computeOptimalBlockOrder();
            for (int i = 0; i < orderedBlocks.size(); i++) {
                IRBlock block = orderedBlocks.get(i);
                // Track what block comes next for fall-through optimization
                nextBlock = (i + 1 < orderedBlocks.size()) ? orderedBlocks.get(i + 1) : null;
                emitBlock(block);
            }
            fixupJumps();
        } catch (IOException e) {
            throw new RuntimeException("Failed to emit bytecode", e);
        }

        return bytecode.toByteArray();
    }

    /**
     * Computes an optimal block ordering that maximizes fall-through opportunities.
     * Uses a greedy algorithm that places fall-through successors immediately after their predecessors.
     */
    private List<IRBlock> computeOptimalBlockOrder() {
        List<IRBlock> order = new ArrayList<>();
        Set<IRBlock> placed = new HashSet<>();
        Deque<IRBlock> worklist = new ArrayDeque<>();

        IRBlock entry = method.getEntryBlock();
        if (entry == null) {
            return method.getBlocksInOrder(); // Fallback to original order
        }

        worklist.add(entry);

        while (!worklist.isEmpty()) {
            IRBlock block = worklist.pollFirst();
            if (placed.contains(block)) continue;

            placed.add(block);
            order.add(block);

            // Determine preferred fall-through successor
            IRBlock fallThrough = getFallThroughSuccessor(block);

            // Add fall-through first (will be processed next)
            if (fallThrough != null && !placed.contains(fallThrough)) {
                worklist.addFirst(fallThrough);
            }

            // Add other successors to back of queue
            for (IRBlock succ : block.getSuccessors()) {
                if (!placed.contains(succ)) {
                    worklist.addLast(succ);
                }
            }
        }

        // Add any remaining blocks (shouldn't happen with well-formed CFG)
        for (IRBlock block : method.getBlocks()) {
            if (!placed.contains(block)) {
                order.add(block);
            }
        }

        return order;
    }

    /**
     * Determines the preferred fall-through successor for a block.
     * For branches, prefers the false target as fall-through.
     * For gotos, the only successor is the fall-through candidate.
     */
    private IRBlock getFallThroughSuccessor(IRBlock block) {
        IRInstruction term = block.getTerminator();
        if (term instanceof BranchInstruction) {
            BranchInstruction branch = (BranchInstruction) term;
            return branch.getFalseTarget();
        }
        if (term instanceof SimpleInstruction) {
            SimpleInstruction simple = (SimpleInstruction) term;
            if (simple.getOp() == SimpleOp.GOTO) {
                return simple.getTarget();
            }
        }
        return null;
    }

    /**
     * Identifies values that can remain on the stack instead of being stored to a register.
     */
    private void analyzeStackResidentValues() {
        stackResidentValues.clear();

        Map<SSAValue, Integer> useCounts = new HashMap<>();
        for (IRBlock block : method.getBlocksInOrder()) {
            for (IRInstruction instr : block.getInstructions()) {
                for (Value operand : instr.getOperands()) {
                    if (operand instanceof SSAValue) {
                        SSAValue ssa = (SSAValue) operand;
                        useCounts.merge(ssa, 1, Integer::sum);
                    }
                }
            }
        }

        for (IRBlock block : method.getBlocksInOrder()) {
            List<IRInstruction> instructions = block.getInstructions();

            for (int i = 0; i < instructions.size() - 1; i++) {
                IRInstruction current = instructions.get(i);
                IRInstruction next = instructions.get(i + 1);

                if (!current.hasResult()) continue;
                SSAValue result = current.getResult();
                if (result == null) continue;

                int useCount = useCounts.getOrDefault(result, 0);
                if (useCount != 1) continue;

                List<Value> nextOperands = next.getOperands();
                if (nextOperands.isEmpty()) continue;

                if (nextOperands.get(0).equals(result)) {
                    if (nextOperands.size() == 1 || isSimpleOperand(nextOperands.get(1))) {
                        stackResidentValues.add(result);
                    }
                }
                else if (nextOperands.size() == 1 && nextOperands.get(0).equals(result)) {
                    stackResidentValues.add(result);
                }
            }
        }
    }

    private boolean isSimpleOperand(Value operand) {
        if (operand instanceof Constant) return true;
        if (operand instanceof SSAValue) {
            SSAValue ssa = (SSAValue) operand;
            String name = ssa.getName();
            return name.startsWith("p") || name.equals("this");
        }
        return false;
    }

    private void emitBlock(IRBlock block) throws IOException {
        blockOffsets.put(block, currentOffset);

        for (IRInstruction instr : block.getInstructions()) {
            emitInstruction(instr);
        }
    }

    private void emitInstruction(IRInstruction instr) throws IOException {
        emitOperandLoads(instr);

        if (instr instanceof ConstantInstruction) {
            ConstantInstruction constInstr = (ConstantInstruction) instr;
            emitConstant(constInstr);
        } else if (instr instanceof LoadLocalInstruction) {
            LoadLocalInstruction load = (LoadLocalInstruction) instr;
            emitLoad(load);
        } else if (instr instanceof StoreLocalInstruction) {
        } else if (instr instanceof BinaryOpInstruction) {
            BinaryOpInstruction binOp = (BinaryOpInstruction) instr;
            emitBinaryOp(binOp);
        } else if (instr instanceof UnaryOpInstruction) {
            UnaryOpInstruction unaryOp = (UnaryOpInstruction) instr;
            emitUnaryOp(unaryOp);
        } else if (instr instanceof SimpleInstruction) {
            SimpleInstruction simple = (SimpleInstruction) instr;
            emitSimple(simple);
        } else if (instr instanceof BranchInstruction) {
            BranchInstruction branch = (BranchInstruction) instr;
            emitBranch(branch);
        } else if (instr instanceof ReturnInstruction) {
            ReturnInstruction ret = (ReturnInstruction) instr;
            emitReturn(ret);
        } else if (instr instanceof InvokeInstruction) {
            InvokeInstruction invoke = (InvokeInstruction) instr;
            emitInvoke(invoke);
        } else if (instr instanceof FieldAccessInstruction) {
            FieldAccessInstruction fieldAccess = (FieldAccessInstruction) instr;
            emitFieldAccess(fieldAccess);
        } else if (instr instanceof NewInstruction) {
            NewInstruction newInstr = (NewInstruction) instr;
            emitNew(newInstr);
        } else if (instr instanceof NewArrayInstruction) {
            NewArrayInstruction newArray = (NewArrayInstruction) instr;
            emitNewArray(newArray);
        } else if (instr instanceof ArrayAccessInstruction) {
            ArrayAccessInstruction arrayAccess = (ArrayAccessInstruction) instr;
            emitArrayAccess(arrayAccess);
        } else if (instr instanceof TypeCheckInstruction) {
            TypeCheckInstruction typeCheck = (TypeCheckInstruction) instr;
            emitTypeCheck(typeCheck);
        } else if (instr instanceof SwitchInstruction) {
            SwitchInstruction switchInstr = (SwitchInstruction) instr;
            emitSwitch(switchInstr);
        } else if (instr instanceof CopyInstruction) {
            CopyInstruction copy = (CopyInstruction) instr;
            emitCopy(copy);
        }

        emitResultStore(instr);
    }

    private void emitOperandLoads(IRInstruction instr) throws IOException {
        if (instr instanceof ConstantInstruction ||
            instr instanceof LoadLocalInstruction ||
            instr instanceof StoreLocalInstruction ||
            instr instanceof CopyInstruction) {
            return;
        }
        if (instr instanceof SimpleInstruction) {
            SimpleInstruction simple = (SimpleInstruction) instr;
            if (simple.getOp() == SimpleOp.GOTO) {
                return;
            }
        }

        for (Value operand : instr.getOperands()) {
            if (operand instanceof SSAValue) {
                SSAValue ssa = (SSAValue) operand;
                if (stackResidentValues.contains(ssa)) {
                    continue;
                }
                emitLoadValue(ssa);
            } else if (operand instanceof Constant) {
                emitConstantValue((Constant) operand);
            }
        }
    }

    private void emitLoadValue(SSAValue value) throws IOException {
        int reg = regAlloc.getRegister(value);
        if (reg < 0) {
            throw new IllegalStateException("No register allocated for value: " + value + " (name=" + value.getName() + ")");
        }
        IRType type = value.getType();

        if (type instanceof PrimitiveType) {
            PrimitiveType prim = (PrimitiveType) type;
            switch (prim) {
                case INT:
                case BOOLEAN:
                case BYTE:
                case CHAR:
                case SHORT:
                    emitVarInsn(Opcode.ILOAD.getCode(), Opcode.ILOAD_0.getCode(), reg);
                    break;
                case LONG:
                    emitVarInsn(Opcode.LLOAD.getCode(), Opcode.LLOAD_0.getCode(), reg);
                    break;
                case FLOAT:
                    emitVarInsn(Opcode.FLOAD.getCode(), Opcode.FLOAD_0.getCode(), reg);
                    break;
                case DOUBLE:
                    emitVarInsn(Opcode.DLOAD.getCode(), Opcode.DLOAD_0.getCode(), reg);
                    break;
            }
        } else {
            emitVarInsn(Opcode.ALOAD.getCode(), Opcode.ALOAD_0.getCode(), reg);
        }
    }

    private void emitConstantValue(Constant constant) throws IOException {
        if (constant instanceof IntConstant) {
            IntConstant intConst = (IntConstant) constant;
            int value = intConst.getValue();
            if (value >= -1 && value <= 5) {
                emit(Opcode.ICONST_0.getCode() + value);
            } else if (value >= Byte.MIN_VALUE && value <= Byte.MAX_VALUE) {
                emit(Opcode.BIPUSH.getCode());
                emit((byte) value);
            } else if (value >= Short.MIN_VALUE && value <= Short.MAX_VALUE) {
                emit(Opcode.SIPUSH.getCode());
                emitShort((short) value);
            } else {
                int index = constPool.findOrAddInteger(value).getIndex(constPool);
                emitLdc(index);
            }
        } else if (constant instanceof LongConstant) {
            LongConstant longConst = (LongConstant) constant;
            long value = longConst.getValue();
            if (value == 0L) emit(Opcode.LCONST_0.getCode());
            else if (value == 1L) emit(Opcode.LCONST_1.getCode());
            else {
                int index = constPool.findOrAddLong(value).getIndex(constPool);
                emit(Opcode.LDC2_W.getCode());
                emitShort((short) index);
            }
        } else if (constant instanceof FloatConstant) {
            FloatConstant floatConst = (FloatConstant) constant;
            float value = floatConst.getValue();
            if (value == 0.0f) emit(Opcode.FCONST_0.getCode());
            else if (value == 1.0f) emit(Opcode.FCONST_1.getCode());
            else if (value == 2.0f) emit(Opcode.FCONST_2.getCode());
            else {
                int index = constPool.findOrAddFloat(value).getIndex(constPool);
                emitLdc(index);
            }
        } else if (constant instanceof DoubleConstant) {
            DoubleConstant doubleConst = (DoubleConstant) constant;
            double value = doubleConst.getValue();
            if (value == 0.0) emit(Opcode.DCONST_0.getCode());
            else if (value == 1.0) emit(Opcode.DCONST_1.getCode());
            else {
                int index = constPool.findOrAddDouble(value).getIndex(constPool);
                emit(Opcode.LDC2_W.getCode());
                emitShort((short) index);
            }
        } else if (constant instanceof StringConstant) {
            StringConstant stringConst = (StringConstant) constant;
            int index = constPool.findOrAddString(stringConst.getValue()).getIndex(constPool);
            emitLdc(index);
        } else if (constant instanceof NullConstant) {
            emit(Opcode.ACONST_NULL.getCode());
        } else if (constant instanceof ClassConstant) {
            ClassConstant classConst = (ClassConstant) constant;
            int index = constPool.findOrAddClass(classConst.getClassName()).getIndex(constPool);
            emitLdc(index);
        }
    }

    private void emitResultStore(IRInstruction instr) throws IOException {
        if (!instr.hasResult()) return;
        SSAValue result = instr.getResult();
        if (result == null) return;

        if (instr instanceof CopyInstruction ||
            instr instanceof LoadLocalInstruction ||
            instr instanceof StoreLocalInstruction) {
            return;
        }

        if (stackResidentValues.contains(result)) {
            return;
        }

        int reg = regAlloc.getRegister(result);
        IRType type = result.getType();

        if (type instanceof PrimitiveType) {
            PrimitiveType prim = (PrimitiveType) type;
            switch (prim) {
                case INT:
                case BOOLEAN:
                case BYTE:
                case CHAR:
                case SHORT:
                    emitVarInsn(Opcode.ISTORE.getCode(), Opcode.ISTORE_0.getCode(), reg);
                    break;
                case LONG:
                    emitVarInsn(Opcode.LSTORE.getCode(), Opcode.LSTORE_0.getCode(), reg);
                    break;
                case FLOAT:
                    emitVarInsn(Opcode.FSTORE.getCode(), Opcode.FSTORE_0.getCode(), reg);
                    break;
                case DOUBLE:
                    emitVarInsn(Opcode.DSTORE.getCode(), Opcode.DSTORE_0.getCode(), reg);
                    break;
            }
        } else {
            emitVarInsn(Opcode.ASTORE.getCode(), Opcode.ASTORE_0.getCode(), reg);
        }
    }

    private void emitConstant(ConstantInstruction instr) throws IOException {
        Constant constant = instr.getConstant();

        if (constant instanceof IntConstant) {
            IntConstant intConst = (IntConstant) constant;
            int value = intConst.getValue();
            if (value >= -1 && value <= 5) {
                emit(Opcode.ICONST_0.getCode() + value);
            } else if (value >= Byte.MIN_VALUE && value <= Byte.MAX_VALUE) {
                emit(Opcode.BIPUSH.getCode());
                emit((byte) value);
            } else if (value >= Short.MIN_VALUE && value <= Short.MAX_VALUE) {
                emit(Opcode.SIPUSH.getCode());
                emitShort((short) value);
            } else {
                int index = constPool.findOrAddInteger(value).getIndex(constPool);
                emitLdc(index);
            }
        } else if (constant instanceof LongConstant) {
            LongConstant longConst = (LongConstant) constant;
            long value = longConst.getValue();
            if (value == 0L) {
                emit(Opcode.LCONST_0.getCode());
            } else if (value == 1L) {
                emit(Opcode.LCONST_1.getCode());
            } else {
                int index = constPool.findOrAddLong(value).getIndex(constPool);
                emit(Opcode.LDC2_W.getCode());
                emitShort((short) index);
            }
        } else if (constant instanceof FloatConstant) {
            FloatConstant floatConst = (FloatConstant) constant;
            float value = floatConst.getValue();
            if (value == 0.0f) {
                emit(Opcode.FCONST_0.getCode());
            } else if (value == 1.0f) {
                emit(Opcode.FCONST_1.getCode());
            } else if (value == 2.0f) {
                emit(Opcode.FCONST_2.getCode());
            } else {
                int index = constPool.findOrAddFloat(value).getIndex(constPool);
                emitLdc(index);
            }
        } else if (constant instanceof DoubleConstant) {
            DoubleConstant doubleConst = (DoubleConstant) constant;
            double value = doubleConst.getValue();
            if (value == 0.0) {
                emit(Opcode.DCONST_0.getCode());
            } else if (value == 1.0) {
                emit(Opcode.DCONST_1.getCode());
            } else {
                int index = constPool.findOrAddDouble(value).getIndex(constPool);
                emit(Opcode.LDC2_W.getCode());
                emitShort((short) index);
            }
        } else if (constant instanceof StringConstant) {
            StringConstant stringConst = (StringConstant) constant;
            int index = constPool.findOrAddString(stringConst.getValue()).getIndex(constPool);
            emitLdc(index);
        } else if (constant instanceof NullConstant) {
            emit(Opcode.ACONST_NULL.getCode());
        } else if (constant instanceof ClassConstant) {
            ClassConstant classConst = (ClassConstant) constant;
            int index = constPool.findOrAddClass(classConst.getClassName()).getIndex(constPool);
            emitLdc(index);
        } else if (constant instanceof MethodHandleConstant) {
            MethodHandleConstant mhConst = (MethodHandleConstant) constant;
            int index = constPool.findOrAddMethodHandle(
                    mhConst.getReferenceKind(),
                    mhConst.getOwner(),
                    mhConst.getName(),
                    mhConst.getDescriptor()
            ).getIndex(constPool);
            emitLdc(index);
        } else if (constant instanceof MethodTypeConstant) {
            MethodTypeConstant mtConst = (MethodTypeConstant) constant;
            int index = constPool.findOrAddMethodType(mtConst.getDescriptor()).getIndex(constPool);
            emitLdc(index);
        } else if (constant instanceof DynamicConstant) {
            DynamicConstant dynConst = (DynamicConstant) constant;
            int cpIndex = dynConst.getOriginalCpIndex();
            if (cpIndex > 0) {
                if (dynConst.getType().isTwoSlot()) {
                    emit(Opcode.LDC2_W.getCode());
                    emitShort((short) cpIndex);
                } else {
                    emitLdc(cpIndex);
                }
            } else {
                throw new UnsupportedOperationException(
                        "Cannot emit DynamicConstant without original constant pool index. " +
                        "Dynamic: " + dynConst.getName() + ":" + dynConst.getDescriptor());
            }
        }
    }

    private void emitLdc(int index) throws IOException {
        if (index <= 0) {
            throw new IllegalStateException("Invalid LDC constant pool index: " + index +
                " (must be > 0). This indicates a constant pool lookup failure.");
        }
        if (index <= 255) {
            emit(Opcode.LDC.getCode());
            emit((byte) index);
        } else {
            emit(Opcode.LDC_W.getCode());
            emitShort((short) index);
        }
    }

    private void emitLoad(LoadLocalInstruction instr) throws IOException {
        // Use the RegisterAllocator's slot for the result value, not the original local index.
        // The original local index may be stale after transformations like method inlining.
        SSAValue result = instr.getResult();
        int index = regAlloc.getRegister(result);
        if (index < 0) {
            // No register allocation for this result - it was likely replaced by replaceAllUsesWith
            // during inlining. Skip emitting this instruction entirely.
            // The value has been replaced with another SSAValue that will be loaded when needed.
            return;
        }
        IRType type = result.getType();

        if (type instanceof PrimitiveType) {
            PrimitiveType prim = (PrimitiveType) type;
            switch (prim) {
                case INT:
                case BOOLEAN:
                case BYTE:
                case CHAR:
                case SHORT:
                    emitVarInsn(Opcode.ILOAD.getCode(), Opcode.ILOAD_0.getCode(), index);
                    break;
                case LONG:
                    emitVarInsn(Opcode.LLOAD.getCode(), Opcode.LLOAD_0.getCode(), index);
                    break;
                case FLOAT:
                    emitVarInsn(Opcode.FLOAD.getCode(), Opcode.FLOAD_0.getCode(), index);
                    break;
                case DOUBLE:
                    emitVarInsn(Opcode.DLOAD.getCode(), Opcode.DLOAD_0.getCode(), index);
                    break;
            }
        } else {
            emitVarInsn(Opcode.ALOAD.getCode(), Opcode.ALOAD_0.getCode(), index);
        }
    }

    private void emitStore(StoreLocalInstruction instr) throws IOException {
        // For StoreLocal, we need to determine the destination slot.
        // The original local index may be stale after transformations like method inlining.
        // Try to use the allocator's slot for the value being stored.
        Value value = instr.getValue();
        int index = instr.getLocalIndex();
        if (value instanceof SSAValue) {
            SSAValue ssa = (SSAValue) value;
            int allocIndex = regAlloc.getRegister(ssa);
            if (allocIndex >= 0) {
                index = allocIndex;
            }
        }
        IRType type = value.getType();

        if (type instanceof PrimitiveType) {
            PrimitiveType prim = (PrimitiveType) type;
            switch (prim) {
                case INT:
                case BOOLEAN:
                case BYTE:
                case CHAR:
                case SHORT:
                    emitVarInsn(Opcode.ISTORE.getCode(), Opcode.ISTORE_0.getCode(), index);
                    break;
                case LONG:
                    emitVarInsn(Opcode.LSTORE.getCode(), Opcode.LSTORE_0.getCode(), index);
                    break;
                case FLOAT:
                    emitVarInsn(Opcode.FSTORE.getCode(), Opcode.FSTORE_0.getCode(), index);
                    break;
                case DOUBLE:
                    emitVarInsn(Opcode.DSTORE.getCode(), Opcode.DSTORE_0.getCode(), index);
                    break;
            }
        } else {
            emitVarInsn(Opcode.ASTORE.getCode(), Opcode.ASTORE_0.getCode(), index);
        }
    }

    private void emitVarInsn(int wideOp, int shortOpBase, int index) throws IOException {
        if (index <= 3) {
            emit(shortOpBase + index);
        } else if (index <= 255) {
            emit(wideOp);
            emit((byte) index);
        } else {
            emit(Opcode.WIDE.getCode());
            emit(wideOp);
            emitShort((short) index);
        }
    }

    private void emitBinaryOp(BinaryOpInstruction instr) throws IOException {
        IRType type = instr.getResult().getType();
        int baseOpcode = getBinaryOpcode(instr.getOp(), type);
        emit(baseOpcode);
    }

    private int getBinaryOpcode(BinaryOp op, IRType type) {
        int typeOffset = getTypeOffset(type);
        switch (op) {
            case ADD:
                return Opcode.IADD.getCode() + typeOffset;
            case SUB:
                return Opcode.ISUB.getCode() + typeOffset;
            case MUL:
                return Opcode.IMUL.getCode() + typeOffset;
            case DIV:
                return Opcode.IDIV.getCode() + typeOffset;
            case REM:
                return Opcode.IREM.getCode() + typeOffset;
            case SHL:
                return type == PrimitiveType.LONG ? Opcode.LSHL.getCode() : Opcode.ISHL.getCode();
            case SHR:
                return type == PrimitiveType.LONG ? Opcode.LSHR.getCode() : Opcode.ISHR.getCode();
            case USHR:
                return type == PrimitiveType.LONG ? Opcode.LUSHR.getCode() : Opcode.IUSHR.getCode();
            case AND:
                return type == PrimitiveType.LONG ? Opcode.LAND.getCode() : Opcode.IAND.getCode();
            case OR:
                return type == PrimitiveType.LONG ? Opcode.LOR.getCode() : Opcode.IOR.getCode();
            case XOR:
                return type == PrimitiveType.LONG ? Opcode.LXOR.getCode() : Opcode.IXOR.getCode();
            case LCMP:
                return Opcode.LCMP.getCode();
            case FCMPL:
                return Opcode.FCMPL.getCode();
            case FCMPG:
                return Opcode.FCMPG.getCode();
            case DCMPL:
                return Opcode.DCMPL.getCode();
            case DCMPG:
                return Opcode.DCMPG.getCode();
            default:
                throw new IllegalArgumentException("Unknown binary op: " + op);
        }
    }

    private int getTypeOffset(IRType type) {
        if (type == PrimitiveType.INT) return 0;
        if (type == PrimitiveType.LONG) return 1;
        if (type == PrimitiveType.FLOAT) return 2;
        if (type == PrimitiveType.DOUBLE) return 3;
        return 0;
    }

    private void emitUnaryOp(UnaryOpInstruction instr) throws IOException {
        int opcode;
        switch (instr.getOp()) {
            case NEG: {
                IRType type = instr.getOperand().getType();
                opcode = Opcode.INEG.getCode() + getTypeOffset(type);
                break;
            }
            case I2L:
                opcode = Opcode.I2L.getCode();
                break;
            case I2F:
                opcode = Opcode.I2F.getCode();
                break;
            case I2D:
                opcode = Opcode.I2D.getCode();
                break;
            case L2I:
                opcode = Opcode.L2I.getCode();
                break;
            case L2F:
                opcode = Opcode.L2F.getCode();
                break;
            case L2D:
                opcode = Opcode.L2D.getCode();
                break;
            case F2I:
                opcode = Opcode.F2I.getCode();
                break;
            case F2L:
                opcode = Opcode.F2L.getCode();
                break;
            case F2D:
                opcode = Opcode.F2D.getCode();
                break;
            case D2I:
                opcode = Opcode.D2I.getCode();
                break;
            case D2L:
                opcode = Opcode.D2L.getCode();
                break;
            case D2F:
                opcode = Opcode.D2F.getCode();
                break;
            case I2B:
                opcode = Opcode.I2B.getCode();
                break;
            case I2C:
                opcode = Opcode.I2C.getCode();
                break;
            case I2S:
                opcode = Opcode.I2S.getCode();
                break;
            default:
                throw new IllegalStateException("Unknown unary op: " + instr.getOp());
        }
        emit(opcode);
    }

    private void emitBranch(BranchInstruction instr) throws IOException {
        int opcode;
        switch (instr.getCondition()) {
            case IFEQ:
                opcode = Opcode.IFEQ.getCode();
                break;
            case IFNE:
                opcode = Opcode.IFNE.getCode();
                break;
            case IFLT:
                opcode = Opcode.IFLT.getCode();
                break;
            case IFGE:
                opcode = Opcode.IFGE.getCode();
                break;
            case IFGT:
                opcode = Opcode.IFGT.getCode();
                break;
            case IFLE:
                opcode = Opcode.IFLE.getCode();
                break;
            case EQ:
                opcode = Opcode.IF_ICMPEQ.getCode();
                break;
            case NE:
                opcode = Opcode.IF_ICMPNE.getCode();
                break;
            case LT:
                opcode = Opcode.IF_ICMPLT.getCode();
                break;
            case GE:
                opcode = Opcode.IF_ICMPGE.getCode();
                break;
            case GT:
                opcode = Opcode.IF_ICMPGT.getCode();
                break;
            case LE:
                opcode = Opcode.IF_ICMPLE.getCode();
                break;
            case ACMPEQ:
                opcode = Opcode.IF_ACMPEQ.getCode();
                break;
            case ACMPNE:
                opcode = Opcode.IF_ACMPNE.getCode();
                break;
            case IFNULL:
                opcode = Opcode.IFNULL.getCode();
                break;
            case IFNONNULL:
                opcode = Opcode.IFNONNULL.getCode();
                break;
            default:
                throw new IllegalStateException("Unknown condition: " + instr.getCondition());
        }

        emit(opcode);
        pendingJumps.add(new PendingJump(currentOffset, instr.getTrueTarget(), false));
        emitShort((short) 0);

        // Skip false-branch goto if target is the next block (fall-through optimization)
        if (instr.getFalseTarget() != nextBlock) {
            emit(Opcode.GOTO.getCode());
            pendingJumps.add(new PendingJump(currentOffset, instr.getFalseTarget(), false));
            emitShort((short) 0);
        }
    }

    private void emitReturn(ReturnInstruction instr) throws IOException {
        if (instr.isVoidReturn()) {
            emit(Opcode.RETURN_.getCode());
        } else {
            IRType type = instr.getReturnValue().getType();
            if (type instanceof PrimitiveType) {
                PrimitiveType prim = (PrimitiveType) type;
                int opcode;
                switch (prim) {
                    case INT:
                    case BOOLEAN:
                    case BYTE:
                    case CHAR:
                    case SHORT:
                        opcode = Opcode.IRETURN.getCode();
                        break;
                    case LONG:
                        opcode = Opcode.LRETURN.getCode();
                        break;
                    case FLOAT:
                        opcode = Opcode.FRETURN.getCode();
                        break;
                    case DOUBLE:
                        opcode = Opcode.DRETURN.getCode();
                        break;
                    default:
                        throw new IllegalStateException("Unknown primitive type: " + prim);
                }
                emit(opcode);
            } else {
                emit(Opcode.ARETURN.getCode());
            }
        }
    }

    private void emitInvoke(InvokeInstruction instr) throws IOException {
        int opcode;
        switch (instr.getInvokeType()) {
            case VIRTUAL:
                opcode = Opcode.INVOKEVIRTUAL.getCode();
                break;
            case SPECIAL:
                opcode = Opcode.INVOKESPECIAL.getCode();
                break;
            case STATIC:
                opcode = Opcode.INVOKESTATIC.getCode();
                break;
            case INTERFACE:
                opcode = Opcode.INVOKEINTERFACE.getCode();
                break;
            case DYNAMIC:
                opcode = Opcode.INVOKEDYNAMIC.getCode();
                break;
            default:
                throw new IllegalStateException("Unknown invoke type: " + instr.getInvokeType());
        }

        if (instr.getInvokeType() == InvokeType.DYNAMIC) {
            int cpIndex = instr.getOriginalCpIndex();
            if (cpIndex > 0) {
                emit(opcode);
                emitShort((short) cpIndex);
                emitShort((short) 0);
            } else {
                throw new UnsupportedOperationException(
                    "Cannot emit INVOKEDYNAMIC without original constant pool index. " +
                    "Method: " + instr.getName() + instr.getDescriptor());
            }
            return;
        }

        int cpIndex;
        if (instr.getInvokeType() == InvokeType.INTERFACE) {
            cpIndex = constPool.findOrAddInterfaceRef(
                    instr.getOwner(), instr.getName(), instr.getDescriptor()
            ).getIndex(constPool);
        } else {
            cpIndex = constPool.findOrAddMethodRef(
                    instr.getOwner(), instr.getName(), instr.getDescriptor()
            ).getIndex(constPool);
        }

        emit(opcode);
        emitShort((short) cpIndex);

        if (instr.getInvokeType() == InvokeType.INTERFACE) {
            emit((byte) (instr.getArguments().size() + 1));
            emit((byte) 0);
        }
    }

    private void emitNew(NewInstruction instr) throws IOException {
        int classRef = constPool.findOrAddClass(instr.getClassName()).getIndex(constPool);
        emit(Opcode.NEW.getCode());
        emitShort((short) classRef);
    }

    private void emitNewArray(NewArrayInstruction instr) throws IOException {
        IRType elemType = instr.getElementType();

        if (elemType instanceof PrimitiveType) {
            PrimitiveType prim = (PrimitiveType) elemType;
            emit(Opcode.NEWARRAY.getCode());
            int atype;
            switch (prim) {
                case BOOLEAN:
                    atype = AccessFlags.T_BOOLEAN;
                    break;
                case CHAR:
                    atype = AccessFlags.T_CHAR;
                    break;
                case FLOAT:
                    atype = AccessFlags.T_FLOAT;
                    break;
                case DOUBLE:
                    atype = AccessFlags.T_DOUBLE;
                    break;
                case BYTE:
                    atype = AccessFlags.T_BYTE;
                    break;
                case SHORT:
                    atype = AccessFlags.T_SHORT;
                    break;
                case INT:
                    atype = AccessFlags.T_INT;
                    break;
                case LONG:
                    atype = AccessFlags.T_LONG;
                    break;
                default:
                    throw new IllegalStateException("Unknown primitive type: " + prim);
            }
            emit((byte) atype);
        } else if (instr.isMultiDimensional()) {
            String desc = instr.getResult().getType().getDescriptor();
            int classRef = constPool.findOrAddClass(desc).getIndex(constPool);
            emit(Opcode.MULTIANEWARRAY.getCode());
            emitShort((short) classRef);
            emit((byte) instr.getDimensions().size());
        } else {
            String className = elemType.getDescriptor();
            if (className.startsWith("L") && className.endsWith(";")) {
                className = className.substring(1, className.length() - 1);
            }
            int classRef = constPool.findOrAddClass(className).getIndex(constPool);
            emit(Opcode.ANEWARRAY.getCode());
            emitShort((short) classRef);
        }
    }

    private void emitFieldAccess(FieldAccessInstruction instr) throws IOException {
        int fieldRef = constPool.findOrAddFieldRef(
                instr.getOwner(), instr.getName(), instr.getDescriptor()
        ).getIndex(constPool);

        if (instr.isLoad()) {
            emit(instr.isStatic() ? Opcode.GETSTATIC.getCode() : Opcode.GETFIELD.getCode());
        } else {
            emit(instr.isStatic() ? Opcode.PUTSTATIC.getCode() : Opcode.PUTFIELD.getCode());
        }
        emitShort((short) fieldRef);
    }

    private void emitArrayAccess(ArrayAccessInstruction instr) throws IOException {
        if (instr.isLoad()) {
            IRType elemType = instr.getResult().getType();
            int opcode;
            if (elemType instanceof PrimitiveType) {
                PrimitiveType prim = (PrimitiveType) elemType;
                switch (prim) {
                    case INT:
                        opcode = Opcode.IALOAD.getCode();
                        break;
                    case LONG:
                        opcode = Opcode.LALOAD.getCode();
                        break;
                    case FLOAT:
                        opcode = Opcode.FALOAD.getCode();
                        break;
                    case DOUBLE:
                        opcode = Opcode.DALOAD.getCode();
                        break;
                    case BYTE:
                    case BOOLEAN:
                        opcode = Opcode.BALOAD.getCode();
                        break;
                    case CHAR:
                        opcode = Opcode.CALOAD.getCode();
                        break;
                    case SHORT:
                        opcode = Opcode.SALOAD.getCode();
                        break;
                    default:
                        throw new IllegalStateException("Unknown primitive type: " + prim);
                }
            } else {
                opcode = Opcode.AALOAD.getCode();
            }
            emit(opcode);
        } else {
            IRType elemType = instr.getValue().getType();
            int opcode;
            if (elemType instanceof PrimitiveType) {
                PrimitiveType prim = (PrimitiveType) elemType;
                switch (prim) {
                    case INT:
                        opcode = Opcode.IASTORE.getCode();
                        break;
                    case LONG:
                        opcode = Opcode.LASTORE.getCode();
                        break;
                    case FLOAT:
                        opcode = Opcode.FASTORE.getCode();
                        break;
                    case DOUBLE:
                        opcode = Opcode.DASTORE.getCode();
                        break;
                    case BYTE:
                    case BOOLEAN:
                        opcode = Opcode.BASTORE.getCode();
                        break;
                    case CHAR:
                        opcode = Opcode.CASTORE.getCode();
                        break;
                    case SHORT:
                        opcode = Opcode.SASTORE.getCode();
                        break;
                    default:
                        throw new IllegalStateException("Unknown primitive type: " + prim);
                }
            } else {
                opcode = Opcode.AASTORE.getCode();
            }
            emit(opcode);
        }
    }

    private void emitTypeCheck(TypeCheckInstruction instr) throws IOException {
        String typeName = instr.getTargetType().getDescriptor();
        if (typeName.startsWith("L") && typeName.endsWith(";")) {
            typeName = typeName.substring(1, typeName.length() - 1);
        }
        int classRef = constPool.findOrAddClass(typeName).getIndex(constPool);

        if (instr.isCast()) {
            emit(Opcode.CHECKCAST.getCode());
        } else {
            emit(Opcode.INSTANCEOF.getCode());
        }
        emitShort((short) classRef);
    }

    private void emitSimple(SimpleInstruction instr) throws IOException {
        switch (instr.getOp()) {
            case ARRAYLENGTH:
                emit(Opcode.ARRAYLENGTH.getCode());
                break;
            case MONITORENTER:
                emit(Opcode.MONITORENTER.getCode());
                break;
            case MONITOREXIT:
                emit(Opcode.MONITOREXIT.getCode());
                break;
            case ATHROW:
                emit(Opcode.ATHROW.getCode());
                break;
            case GOTO:
                if (instr.getTarget() != nextBlock) {
                    emit(Opcode.GOTO.getCode());
                    pendingJumps.add(new PendingJump(currentOffset, instr.getTarget(), false));
                    emitShort((short) 0);
                }
                break;
            default:
                throw new IllegalStateException("Unknown simple op: " + instr.getOp());
        }
    }

    private void emitSwitch(SwitchInstruction instr) throws IOException {
        Map<Integer, IRBlock> cases = instr.getCases();
        List<Integer> keys = new ArrayList<>(cases.keySet());
        Collections.sort(keys);

        if (keys.isEmpty()) {
            emit(Opcode.GOTO.getCode());
            pendingJumps.add(new PendingJump(currentOffset, instr.getDefaultTarget(), false));
            emitShort((short) 0);
            return;
        }

        int low = keys.get(0);
        int high = keys.get(keys.size() - 1);
        boolean useTableSwitch = (high - low + 1) <= keys.size() * 2;

        int switchStart = currentOffset;
        if (useTableSwitch) {
            emit(Opcode.TABLESWITCH.getCode());
        } else {
            emit(Opcode.LOOKUPSWITCH.getCode());
        }

        while (currentOffset % 4 != 0) {
            emit(Opcode.NOP.getCode());
        }

        pendingJumps.add(new PendingJump(currentOffset, instr.getDefaultTarget(), true));
        emitInt(0);

        if (useTableSwitch) {
            emitInt(low);
            emitInt(high);
            for (int key = low; key <= high; key++) {
                IRBlock target = cases.getOrDefault(key, instr.getDefaultTarget());
                pendingJumps.add(new PendingJump(currentOffset, target, true));
                emitInt(0);
            }
        } else {
            emitInt(keys.size());
            for (int key : keys) {
                emitInt(key);
                pendingJumps.add(new PendingJump(currentOffset, cases.get(key), true));
                emitInt(0);
            }
        }
    }

    /**
     * For phi copy values, returns the phi result's register slot.
     * Returns -1 if the value is not a phi copy.
     */
    private int getPhiCopyDestination(SSAValue copyValue) {
        Map<SSAValue, List<CopyInfo>> phiCopies = method.getPhiCopyMapping();
        if (phiCopies == null) return -1;

        for (Map.Entry<SSAValue, List<CopyInfo>> entry : phiCopies.entrySet()) {
            for (CopyInfo copyInfo : entry.getValue()) {
                if (copyInfo.copyValue().equals(copyValue)) {
                    // This is a phi copy - return the phi result's register
                    return regAlloc.getRegister(entry.getKey());
                }
            }
        }
        return -1;
    }

    private void emitCopy(CopyInstruction instr) throws IOException {
        Value source = instr.getSource();

        // For phi copies, the destination should be the phi result's slot, not the copy's slot
        int dstReg = getPhiCopyDestination(instr.getResult());
        if (dstReg < 0) {
            dstReg = regAlloc.getRegister(instr.getResult());
        }

        if (source instanceof SSAValue) {
            SSAValue ssa = (SSAValue) source;
            if (stackResidentValues.contains(ssa)) {
                IRType type = ssa.getType();
                if (type instanceof PrimitiveType) {
                    PrimitiveType prim = (PrimitiveType) type;
                    switch (prim) {
                        case INT:
                        case BOOLEAN:
                        case BYTE:
                        case CHAR:
                        case SHORT:
                            emitVarInsn(Opcode.ISTORE.getCode(), Opcode.ISTORE_0.getCode(), dstReg);
                            break;
                        case LONG:
                            emitVarInsn(Opcode.LSTORE.getCode(), Opcode.LSTORE_0.getCode(), dstReg);
                            break;
                        case FLOAT:
                            emitVarInsn(Opcode.FSTORE.getCode(), Opcode.FSTORE_0.getCode(), dstReg);
                            break;
                        case DOUBLE:
                            emitVarInsn(Opcode.DSTORE.getCode(), Opcode.DSTORE_0.getCode(), dstReg);
                            break;
                    }
                } else {
                    emitVarInsn(Opcode.ASTORE.getCode(), Opcode.ASTORE_0.getCode(), dstReg);
                }
            } else {
                int srcReg = regAlloc.getRegister(ssa);
                if (srcReg != dstReg) {
                    IRType type = ssa.getType();
                    emitVarInsn(getLoadOpcode(type), getLoadShortBase(type), srcReg);
                    emitVarInsn(getStoreOpcode(type), getStoreShortBase(type), dstReg);
                }
            }
        } else if (source instanceof Constant) {
            Constant constant = (Constant) source;
            emitConstantValue(constant);
            IRType type = constant.getType();
            if (type instanceof PrimitiveType) {
                PrimitiveType prim = (PrimitiveType) type;
                switch (prim) {
                    case INT:
                    case BOOLEAN:
                    case BYTE:
                    case CHAR:
                    case SHORT:
                        emitVarInsn(Opcode.ISTORE.getCode(), Opcode.ISTORE_0.getCode(), dstReg);
                        break;
                    case LONG:
                        emitVarInsn(Opcode.LSTORE.getCode(), Opcode.LSTORE_0.getCode(), dstReg);
                        break;
                    case FLOAT:
                        emitVarInsn(Opcode.FSTORE.getCode(), Opcode.FSTORE_0.getCode(), dstReg);
                        break;
                    case DOUBLE:
                        emitVarInsn(Opcode.DSTORE.getCode(), Opcode.DSTORE_0.getCode(), dstReg);
                        break;
                }
            } else {
                emitVarInsn(Opcode.ASTORE.getCode(), Opcode.ASTORE_0.getCode(), dstReg);
            }
        }
    }

    private int getLoadOpcode(IRType type) {
        if (type instanceof PrimitiveType) {
            PrimitiveType prim = (PrimitiveType) type;
            switch (prim) {
                case INT:
                case BOOLEAN:
                case BYTE:
                case CHAR:
                case SHORT:
                    return Opcode.ILOAD.getCode();
                case LONG:
                    return Opcode.LLOAD.getCode();
                case FLOAT:
                    return Opcode.FLOAD.getCode();
                case DOUBLE:
                    return Opcode.DLOAD.getCode();
            }
        }
        return Opcode.ALOAD.getCode();
    }

    private int getLoadShortBase(IRType type) {
        if (type instanceof PrimitiveType) {
            PrimitiveType prim = (PrimitiveType) type;
            switch (prim) {
                case INT:
                case BOOLEAN:
                case BYTE:
                case CHAR:
                case SHORT:
                    return Opcode.ILOAD_0.getCode();
                case LONG:
                    return Opcode.LLOAD_0.getCode();
                case FLOAT:
                    return Opcode.FLOAD_0.getCode();
                case DOUBLE:
                    return Opcode.DLOAD_0.getCode();
            }
        }
        return Opcode.ALOAD_0.getCode();
    }

    private int getStoreOpcode(IRType type) {
        if (type instanceof PrimitiveType) {
            PrimitiveType prim = (PrimitiveType) type;
            switch (prim) {
                case INT:
                case BOOLEAN:
                case BYTE:
                case CHAR:
                case SHORT:
                    return Opcode.ISTORE.getCode();
                case LONG:
                    return Opcode.LSTORE.getCode();
                case FLOAT:
                    return Opcode.FSTORE.getCode();
                case DOUBLE:
                    return Opcode.DSTORE.getCode();
            }
        }
        return Opcode.ASTORE.getCode();
    }

    private int getStoreShortBase(IRType type) {
        if (type instanceof PrimitiveType) {
            PrimitiveType prim = (PrimitiveType) type;
            switch (prim) {
                case INT:
                case BOOLEAN:
                case BYTE:
                case CHAR:
                case SHORT:
                    return Opcode.ISTORE_0.getCode();
                case LONG:
                    return Opcode.LSTORE_0.getCode();
                case FLOAT:
                    return Opcode.FSTORE_0.getCode();
                case DOUBLE:
                    return Opcode.DSTORE_0.getCode();
            }
        }
        return Opcode.ASTORE_0.getCode();
    }

    private void fixupJumps() {
        byte[] code = bytecode.toByteArray();
        for (PendingJump jump : pendingJumps) {
            int targetOffset = blockOffsets.getOrDefault(jump.target(), 0);
            int opcodeOffset = jump.offset() - 1;
            int relativeOffset = targetOffset - opcodeOffset;

            if (jump.isWide()) {
                code[jump.offset()] = (byte) (relativeOffset >> 24);
                code[jump.offset() + 1] = (byte) (relativeOffset >> 16);
                code[jump.offset() + 2] = (byte) (relativeOffset >> 8);
                code[jump.offset() + 3] = (byte) relativeOffset;
            } else {
                // Check for overflow - offset must fit in signed 16-bit
                if (relativeOffset < Short.MIN_VALUE || relativeOffset > Short.MAX_VALUE) {
                    throw new IllegalStateException(
                        "Branch offset " + relativeOffset + " exceeds 16-bit range. " +
                        "Method is too large and requires wide branch instructions (goto_w).");
                }
                code[jump.offset()] = (byte) (relativeOffset >> 8);
                code[jump.offset() + 1] = (byte) relativeOffset;
            }
        }
        bytecode = new ByteArrayOutputStream();
        try {
            bytecode.write(code);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private void emit(int b) throws IOException {
        dos.writeByte(b);
        currentOffset++;
    }

    private void emitShort(short s) throws IOException {
        dos.writeShort(s);
        currentOffset += 2;
    }

    private void emitInt(int i) throws IOException {
        dos.writeInt(i);
        currentOffset += 4;
    }

    private static final class PendingJump {
        private final int offset;
        private final IRBlock target;
        private final boolean isWide;

        public PendingJump(int offset, IRBlock target, boolean isWide) {
            this.offset = offset;
            this.target = target;
            this.isWide = isWide;
        }

        public int offset() {
            return offset;
        }

        public IRBlock target() {
            return target;
        }

        public boolean isWide() {
            return isWide;
        }

        @Override
        public boolean equals(Object obj) {
            if (this == obj) return true;
            if (obj == null || getClass() != obj.getClass()) return false;
            PendingJump that = (PendingJump) obj;
            return offset == that.offset &&
                   isWide == that.isWide &&
                   Objects.equals(target, that.target);
        }

        @Override
        public int hashCode() {
            return Objects.hash(offset, target, isWide);
        }

        @Override
        public String toString() {
            return "PendingJump{" +
                   "offset=" + offset +
                   ", target=" + target +
                   ", isWide=" + isWide +
                   '}';
        }
    }
}
