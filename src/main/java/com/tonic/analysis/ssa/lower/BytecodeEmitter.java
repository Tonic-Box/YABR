package com.tonic.analysis.ssa.lower;

import com.tonic.analysis.ssa.cfg.IRBlock;
import com.tonic.analysis.ssa.cfg.IRMethod;
import com.tonic.analysis.ssa.ir.*;
import com.tonic.analysis.ssa.type.*;
import com.tonic.analysis.ssa.value.*;
import com.tonic.parser.ConstPool;
import lombok.Getter;

import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.util.*;

/**
 * Emits JVM bytecode from IR instructions.
 */
@Getter
public class BytecodeEmitter {

    private final IRMethod method;
    private final ConstPool constPool;
    private final RegisterAllocator regAlloc;
    private final StackScheduler scheduler;

    private ByteArrayOutputStream bytecode;
    private DataOutputStream dos;
    private Map<IRBlock, Integer> blockOffsets;
    private List<PendingJump> pendingJumps;
    private int currentOffset;

    private Set<SSAValue> stackResidentValues;

    // For fall-through optimization
    private IRBlock nextBlock;

    /**
     * Creates a new bytecode emitter.
     *
     * @param method the IR method to emit
     * @param constPool the constant pool
     * @param regAlloc the register allocator
     * @param scheduler the stack scheduler
     */
    public BytecodeEmitter(IRMethod method, ConstPool constPool, RegisterAllocator regAlloc, StackScheduler scheduler) {
        this.method = method;
        this.constPool = constPool;
        this.regAlloc = regAlloc;
        this.scheduler = scheduler;
        this.blockOffsets = new HashMap<>();
        this.pendingJumps = new ArrayList<>();
        this.stackResidentValues = new HashSet<>();
    }

    /**
     * Emits bytecode for the IR method.
     *
     * @return the generated bytecode
     */
    public byte[] emit() {
        bytecode = new ByteArrayOutputStream();
        dos = new DataOutputStream(bytecode);
        currentOffset = 0;

        analyzeStackResidentValues();

        try {
            List<IRBlock> orderedBlocks = computeOptimalBlockOrder();
            for (int i = 0; i < orderedBlocks.size(); i++) {
                IRBlock block = orderedBlocks.get(i);
                // Track what block comes next for fall-through optimization
                nextBlock = (i + 1 < orderedBlocks.size()) ? orderedBlocks.get(i + 1) : null;
                emitBlock(block);
            }
            fixupJumps();
        } catch (IOException e) {
            throw new RuntimeException("Failed to emit bytecode", e);
        }

        return bytecode.toByteArray();
    }

    /**
     * Computes an optimal block ordering that maximizes fall-through opportunities.
     * Uses a greedy algorithm that places fall-through successors immediately after their predecessors.
     */
    private List<IRBlock> computeOptimalBlockOrder() {
        List<IRBlock> order = new ArrayList<>();
        Set<IRBlock> placed = new HashSet<>();
        Deque<IRBlock> worklist = new ArrayDeque<>();

        IRBlock entry = method.getEntryBlock();
        if (entry == null) {
            return method.getBlocksInOrder(); // Fallback to original order
        }

        worklist.add(entry);

        while (!worklist.isEmpty()) {
            IRBlock block = worklist.pollFirst();
            if (placed.contains(block)) continue;

            placed.add(block);
            order.add(block);

            // Determine preferred fall-through successor
            IRBlock fallThrough = getFallThroughSuccessor(block);

            // Add fall-through first (will be processed next)
            if (fallThrough != null && !placed.contains(fallThrough)) {
                worklist.addFirst(fallThrough);
            }

            // Add other successors to back of queue
            for (IRBlock succ : block.getSuccessors()) {
                if (!placed.contains(succ)) {
                    worklist.addLast(succ);
                }
            }
        }

        // Add any remaining blocks (shouldn't happen with well-formed CFG)
        for (IRBlock block : method.getBlocks()) {
            if (!placed.contains(block)) {
                order.add(block);
            }
        }

        return order;
    }

    /**
     * Determines the preferred fall-through successor for a block.
     * For branches, prefers the false target as fall-through.
     * For gotos, the only successor is the fall-through candidate.
     */
    private IRBlock getFallThroughSuccessor(IRBlock block) {
        IRInstruction term = block.getTerminator();
        if (term instanceof BranchInstruction) {
            BranchInstruction branch = (BranchInstruction) term;
            // Prefer false branch as fall-through (allows skipping the goto)
            return branch.getFalseTarget();
        }
        if (term instanceof GotoInstruction) {
            GotoInstruction gotoInstr = (GotoInstruction) term;
            // Goto's target is the only successor - prefer it as fall-through
            return gotoInstr.getTarget();
        }
        return null;
    }

    /**
     * Identifies values that can remain on the stack instead of being stored to a register.
     */
    private void analyzeStackResidentValues() {
        stackResidentValues.clear();

        Map<SSAValue, Integer> useCounts = new HashMap<>();
        for (IRBlock block : method.getBlocksInOrder()) {
            for (IRInstruction instr : block.getInstructions()) {
                for (Value operand : instr.getOperands()) {
                    if (operand instanceof SSAValue) {
                        SSAValue ssa = (SSAValue) operand;
                        useCounts.merge(ssa, 1, Integer::sum);
                    }
                }
            }
        }

        for (IRBlock block : method.getBlocksInOrder()) {
            List<IRInstruction> instructions = block.getInstructions();

            for (int i = 0; i < instructions.size() - 1; i++) {
                IRInstruction current = instructions.get(i);
                IRInstruction next = instructions.get(i + 1);

                if (!current.hasResult()) continue;
                SSAValue result = current.getResult();
                if (result == null) continue;

                int useCount = useCounts.getOrDefault(result, 0);
                if (useCount != 1) continue;

                List<Value> nextOperands = next.getOperands();
                if (nextOperands.isEmpty()) continue;

                if (nextOperands.get(0).equals(result)) {
                    if (nextOperands.size() == 1 || isSimpleOperand(nextOperands.get(1))) {
                        stackResidentValues.add(result);
                    }
                }
                else if (nextOperands.size() == 1 && nextOperands.get(0).equals(result)) {
                    stackResidentValues.add(result);
                }
            }
        }
    }

    private boolean isSimpleOperand(Value operand) {
        if (operand instanceof Constant) return true;
        if (operand instanceof SSAValue) {
            SSAValue ssa = (SSAValue) operand;
            String name = ssa.getName();
            return name.startsWith("p") || name.equals("this");
        }
        return false;
    }

    private void emitBlock(IRBlock block) throws IOException {
        blockOffsets.put(block, currentOffset);

        for (IRInstruction instr : block.getInstructions()) {
            emitInstruction(instr);
        }
    }

    private void emitInstruction(IRInstruction instr) throws IOException {
        emitOperandLoads(instr);

        if (instr instanceof ConstantInstruction) {
            ConstantInstruction constInstr = (ConstantInstruction) instr;
            emitConstant(constInstr);
        } else if (instr instanceof LoadLocalInstruction) {
            LoadLocalInstruction load = (LoadLocalInstruction) instr;
            emitLoad(load);
        } else if (instr instanceof StoreLocalInstruction) {
        } else if (instr instanceof BinaryOpInstruction) {
            BinaryOpInstruction binOp = (BinaryOpInstruction) instr;
            emitBinaryOp(binOp);
        } else if (instr instanceof UnaryOpInstruction) {
            UnaryOpInstruction unaryOp = (UnaryOpInstruction) instr;
            emitUnaryOp(unaryOp);
        } else if (instr instanceof GotoInstruction) {
            GotoInstruction gotoInstr = (GotoInstruction) instr;
            emitGoto(gotoInstr);
        } else if (instr instanceof BranchInstruction) {
            BranchInstruction branch = (BranchInstruction) instr;
            emitBranch(branch);
        } else if (instr instanceof ReturnInstruction) {
            ReturnInstruction ret = (ReturnInstruction) instr;
            emitReturn(ret);
        } else if (instr instanceof InvokeInstruction) {
            InvokeInstruction invoke = (InvokeInstruction) instr;
            emitInvoke(invoke);
        } else if (instr instanceof GetFieldInstruction) {
            GetFieldInstruction getField = (GetFieldInstruction) instr;
            emitGetField(getField);
        } else if (instr instanceof PutFieldInstruction) {
            PutFieldInstruction putField = (PutFieldInstruction) instr;
            emitPutField(putField);
        } else if (instr instanceof NewInstruction) {
            NewInstruction newInstr = (NewInstruction) instr;
            emitNew(newInstr);
        } else if (instr instanceof NewArrayInstruction) {
            NewArrayInstruction newArray = (NewArrayInstruction) instr;
            emitNewArray(newArray);
        } else if (instr instanceof ArrayLoadInstruction) {
            ArrayLoadInstruction arrayLoad = (ArrayLoadInstruction) instr;
            emitArrayLoad(arrayLoad);
        } else if (instr instanceof ArrayStoreInstruction) {
            ArrayStoreInstruction arrayStore = (ArrayStoreInstruction) instr;
            emitArrayStore(arrayStore);
        } else if (instr instanceof ArrayLengthInstruction) {
            emit(0xBE);
        } else if (instr instanceof ThrowInstruction) {
            emit(0xBF);
        } else if (instr instanceof CastInstruction) {
            CastInstruction cast = (CastInstruction) instr;
            emitCast(cast);
        } else if (instr instanceof InstanceOfInstruction) {
            InstanceOfInstruction instanceOf = (InstanceOfInstruction) instr;
            emitInstanceOf(instanceOf);
        } else if (instr instanceof MonitorEnterInstruction) {
            emit(0xC2);
        } else if (instr instanceof MonitorExitInstruction) {
            emit(0xC3);
        } else if (instr instanceof SwitchInstruction) {
            SwitchInstruction switchInstr = (SwitchInstruction) instr;
            emitSwitch(switchInstr);
        } else if (instr instanceof CopyInstruction) {
            CopyInstruction copy = (CopyInstruction) instr;
            emitCopy(copy);
        }

        emitResultStore(instr);
    }

    private void emitOperandLoads(IRInstruction instr) throws IOException {
        if (instr instanceof ConstantInstruction ||
            instr instanceof LoadLocalInstruction ||
            instr instanceof StoreLocalInstruction ||
            instr instanceof GotoInstruction ||
            instr instanceof CopyInstruction) {
            return;
        }

        for (Value operand : instr.getOperands()) {
            if (operand instanceof SSAValue) {
                SSAValue ssa = (SSAValue) operand;
                if (stackResidentValues.contains(ssa)) {
                    continue;
                }
                emitLoadValue(ssa);
            } else if (operand instanceof Constant) {
                emitConstantValue((Constant) operand);
            }
        }
    }

    private void emitLoadValue(SSAValue value) throws IOException {
        int reg = regAlloc.getRegister(value);
        if (reg < 0) {
            throw new IllegalStateException("No register allocated for value: " + value + " (name=" + value.getName() + ")");
        }
        IRType type = value.getType();

        if (type instanceof PrimitiveType) {
            PrimitiveType prim = (PrimitiveType) type;
            switch (prim) {
                case INT:
                case BOOLEAN:
                case BYTE:
                case CHAR:
                case SHORT:
                    emitVarInsn(0x15, 0x1A, reg);
                    break;
                case LONG:
                    emitVarInsn(0x16, 0x1E, reg);
                    break;
                case FLOAT:
                    emitVarInsn(0x17, 0x22, reg);
                    break;
                case DOUBLE:
                    emitVarInsn(0x18, 0x26, reg);
                    break;
            }
        } else {
            emitVarInsn(0x19, 0x2A, reg);
        }
    }

    private void emitConstantValue(Constant constant) throws IOException {
        if (constant instanceof IntConstant) {
            IntConstant intConst = (IntConstant) constant;
            int value = intConst.getValue();
            if (value >= -1 && value <= 5) {
                emit(0x03 + value);
            } else if (value >= Byte.MIN_VALUE && value <= Byte.MAX_VALUE) {
                emit(0x10);
                emit((byte) value);
            } else if (value >= Short.MIN_VALUE && value <= Short.MAX_VALUE) {
                emit(0x11);
                emitShort((short) value);
            } else {
                int index = constPool.findOrAddInteger(value).getIndex(constPool);
                emitLdc(index);
            }
        } else if (constant instanceof LongConstant) {
            LongConstant longConst = (LongConstant) constant;
            long value = longConst.getValue();
            if (value == 0L) emit(0x09);
            else if (value == 1L) emit(0x0A);
            else {
                int index = constPool.findOrAddLong(value).getIndex(constPool);
                emit(0x14);
                emitShort((short) index);
            }
        } else if (constant instanceof FloatConstant) {
            FloatConstant floatConst = (FloatConstant) constant;
            float value = floatConst.getValue();
            if (value == 0.0f) emit(0x0B);
            else if (value == 1.0f) emit(0x0C);
            else if (value == 2.0f) emit(0x0D);
            else {
                int index = constPool.findOrAddFloat(value).getIndex(constPool);
                emitLdc(index);
            }
        } else if (constant instanceof DoubleConstant) {
            DoubleConstant doubleConst = (DoubleConstant) constant;
            double value = doubleConst.getValue();
            if (value == 0.0) emit(0x0E);
            else if (value == 1.0) emit(0x0F);
            else {
                int index = constPool.findOrAddDouble(value).getIndex(constPool);
                emit(0x14);
                emitShort((short) index);
            }
        } else if (constant instanceof StringConstant) {
            StringConstant stringConst = (StringConstant) constant;
            int index = constPool.findOrAddString(stringConst.getValue()).getIndex(constPool);
            emitLdc(index);
        } else if (constant instanceof NullConstant) {
            emit(0x01);
        } else if (constant instanceof ClassConstant) {
            ClassConstant classConst = (ClassConstant) constant;
            int index = constPool.findOrAddClass(classConst.getClassName()).getIndex(constPool);
            emitLdc(index);
        }
    }

    private void emitResultStore(IRInstruction instr) throws IOException {
        if (!instr.hasResult()) return;
        SSAValue result = instr.getResult();
        if (result == null) return;

        if (instr instanceof CopyInstruction ||
            instr instanceof LoadLocalInstruction ||
            instr instanceof StoreLocalInstruction) {
            return;
        }

        if (stackResidentValues.contains(result)) {
            return;
        }

        int reg = regAlloc.getRegister(result);
        IRType type = result.getType();

        if (type instanceof PrimitiveType) {
            PrimitiveType prim = (PrimitiveType) type;
            switch (prim) {
                case INT:
                case BOOLEAN:
                case BYTE:
                case CHAR:
                case SHORT:
                    emitVarInsn(0x36, 0x3B, reg);
                    break;
                case LONG:
                    emitVarInsn(0x37, 0x3F, reg);
                    break;
                case FLOAT:
                    emitVarInsn(0x38, 0x43, reg);
                    break;
                case DOUBLE:
                    emitVarInsn(0x39, 0x47, reg);
                    break;
            }
        } else {
            emitVarInsn(0x3A, 0x4B, reg);
        }
    }

    private void emitConstant(ConstantInstruction instr) throws IOException {
        Constant constant = instr.getConstant();

        if (constant instanceof IntConstant) {
            IntConstant intConst = (IntConstant) constant;
            int value = intConst.getValue();
            if (value >= -1 && value <= 5) {
                emit(0x03 + value);
            } else if (value >= Byte.MIN_VALUE && value <= Byte.MAX_VALUE) {
                emit(0x10);
                emit((byte) value);
            } else if (value >= Short.MIN_VALUE && value <= Short.MAX_VALUE) {
                emit(0x11);
                emitShort((short) value);
            } else {
                int index = constPool.findOrAddInteger(value).getIndex(constPool);
                emitLdc(index);
            }
        } else if (constant instanceof LongConstant) {
            LongConstant longConst = (LongConstant) constant;
            long value = longConst.getValue();
            if (value == 0L) {
                emit(0x09);
            } else if (value == 1L) {
                emit(0x0A);
            } else {
                int index = constPool.findOrAddLong(value).getIndex(constPool);
                emit(0x14);
                emitShort((short) index);
            }
        } else if (constant instanceof FloatConstant) {
            FloatConstant floatConst = (FloatConstant) constant;
            float value = floatConst.getValue();
            if (value == 0.0f) {
                emit(0x0B);
            } else if (value == 1.0f) {
                emit(0x0C);
            } else if (value == 2.0f) {
                emit(0x0D);
            } else {
                int index = constPool.findOrAddFloat(value).getIndex(constPool);
                emitLdc(index);
            }
        } else if (constant instanceof DoubleConstant) {
            DoubleConstant doubleConst = (DoubleConstant) constant;
            double value = doubleConst.getValue();
            if (value == 0.0) {
                emit(0x0E);
            } else if (value == 1.0) {
                emit(0x0F);
            } else {
                int index = constPool.findOrAddDouble(value).getIndex(constPool);
                emit(0x14);
                emitShort((short) index);
            }
        } else if (constant instanceof StringConstant) {
            StringConstant stringConst = (StringConstant) constant;
            int index = constPool.findOrAddString(stringConst.getValue()).getIndex(constPool);
            emitLdc(index);
        } else if (constant instanceof NullConstant) {
            emit(0x01);
        } else if (constant instanceof ClassConstant) {
            ClassConstant classConst = (ClassConstant) constant;
            int index = constPool.findOrAddClass(classConst.getClassName()).getIndex(constPool);
            emitLdc(index);
        } else if (constant instanceof MethodHandleConstant) {
            MethodHandleConstant mhConst = (MethodHandleConstant) constant;
            int index = constPool.findOrAddMethodHandle(
                    mhConst.getReferenceKind(),
                    mhConst.getOwner(),
                    mhConst.getName(),
                    mhConst.getDescriptor()
            ).getIndex(constPool);
            emitLdc(index);
        } else if (constant instanceof MethodTypeConstant) {
            MethodTypeConstant mtConst = (MethodTypeConstant) constant;
            int index = constPool.findOrAddMethodType(mtConst.getDescriptor()).getIndex(constPool);
            emitLdc(index);
        } else if (constant instanceof DynamicConstant) {
            DynamicConstant dynConst = (DynamicConstant) constant;
            // For condy, use original CP index if available (roundtrip preservation)
            int cpIndex = dynConst.getOriginalCpIndex();
            if (cpIndex > 0) {
                if (dynConst.getType().isTwoSlot()) {
                    emit(0x14); // ldc2_w
                    emitShort((short) cpIndex);
                } else {
                    emitLdc(cpIndex);
                }
            } else {
                throw new UnsupportedOperationException(
                        "Cannot emit DynamicConstant without original constant pool index. " +
                        "Dynamic: " + dynConst.getName() + ":" + dynConst.getDescriptor());
            }
        }
    }

    private void emitLdc(int index) throws IOException {
        if (index <= 255) {
            emit(0x12);
            emit((byte) index);
        } else {
            emit(0x13);
            emitShort((short) index);
        }
    }

    private void emitLoad(LoadLocalInstruction instr) throws IOException {
        // Use the RegisterAllocator's slot for the result value, not the original local index.
        // The original local index may be stale after transformations like method inlining.
        SSAValue result = instr.getResult();
        int index = regAlloc.getRegister(result);
        if (index < 0) {
            // No register allocation for this result - it was likely replaced by replaceAllUsesWith
            // during inlining. Skip emitting this instruction entirely.
            // The value has been replaced with another SSAValue that will be loaded when needed.
            return;
        }
        IRType type = result.getType();

        if (type instanceof PrimitiveType) {
            PrimitiveType prim = (PrimitiveType) type;
            switch (prim) {
                case INT:
                case BOOLEAN:
                case BYTE:
                case CHAR:
                case SHORT:
                    emitVarInsn(0x15, 0x1A, index);
                    break;
                case LONG:
                    emitVarInsn(0x16, 0x1E, index);
                    break;
                case FLOAT:
                    emitVarInsn(0x17, 0x22, index);
                    break;
                case DOUBLE:
                    emitVarInsn(0x18, 0x26, index);
                    break;
            }
        } else {
            emitVarInsn(0x19, 0x2A, index);
        }
    }

    private void emitStore(StoreLocalInstruction instr) throws IOException {
        // For StoreLocal, we need to determine the destination slot.
        // The original local index may be stale after transformations like method inlining.
        // Try to use the allocator's slot for the value being stored.
        Value value = instr.getValue();
        int index = instr.getLocalIndex();
        if (value instanceof SSAValue) {
            SSAValue ssa = (SSAValue) value;
            int allocIndex = regAlloc.getRegister(ssa);
            if (allocIndex >= 0) {
                index = allocIndex;
            }
        }
        IRType type = value.getType();

        if (type instanceof PrimitiveType) {
            PrimitiveType prim = (PrimitiveType) type;
            switch (prim) {
                case INT:
                case BOOLEAN:
                case BYTE:
                case CHAR:
                case SHORT:
                    emitVarInsn(0x36, 0x3B, index);
                    break;
                case LONG:
                    emitVarInsn(0x37, 0x3F, index);
                    break;
                case FLOAT:
                    emitVarInsn(0x38, 0x43, index);
                    break;
                case DOUBLE:
                    emitVarInsn(0x39, 0x47, index);
                    break;
            }
        } else {
            emitVarInsn(0x3A, 0x4B, index);
        }
    }

    private void emitVarInsn(int wideOp, int shortOpBase, int index) throws IOException {
        if (index <= 3) {
            emit(shortOpBase + index);
        } else if (index <= 255) {
            emit(wideOp);
            emit((byte) index);
        } else {
            emit(0xC4);
            emit(wideOp);
            emitShort((short) index);
        }
    }

    private void emitBinaryOp(BinaryOpInstruction instr) throws IOException {
        IRType type = instr.getResult().getType();
        int baseOpcode = getBinaryOpcode(instr.getOp(), type);
        emit(baseOpcode);
    }

    private int getBinaryOpcode(BinaryOp op, IRType type) {
        int typeOffset = getTypeOffset(type);
        switch (op) {
            case ADD:
                return 0x60 + typeOffset;
            case SUB:
                return 0x64 + typeOffset;
            case MUL:
                return 0x68 + typeOffset;
            case DIV:
                return 0x6C + typeOffset;
            case REM:
                return 0x70 + typeOffset;
            case SHL:
                return type == PrimitiveType.LONG ? 0x79 : 0x78;
            case SHR:
                return type == PrimitiveType.LONG ? 0x7B : 0x7A;
            case USHR:
                return type == PrimitiveType.LONG ? 0x7D : 0x7C;
            case AND:
                return type == PrimitiveType.LONG ? 0x7F : 0x7E;
            case OR:
                return type == PrimitiveType.LONG ? 0x81 : 0x80;
            case XOR:
                return type == PrimitiveType.LONG ? 0x83 : 0x82;
            case LCMP:
                return 0x94;
            case FCMPL:
                return 0x95;
            case FCMPG:
                return 0x96;
            case DCMPL:
                return 0x97;
            case DCMPG:
                return 0x98;
            default:
                throw new IllegalArgumentException("Unknown binary op: " + op);
        }
    }

    private int getTypeOffset(IRType type) {
        if (type == PrimitiveType.INT) return 0;
        if (type == PrimitiveType.LONG) return 1;
        if (type == PrimitiveType.FLOAT) return 2;
        if (type == PrimitiveType.DOUBLE) return 3;
        return 0;
    }

    private void emitUnaryOp(UnaryOpInstruction instr) throws IOException {
        int opcode;
        switch (instr.getOp()) {
            case NEG: {
                IRType type = instr.getOperand().getType();
                opcode = 0x74 + getTypeOffset(type);
                break;
            }
            case I2L:
                opcode = 0x85;
                break;
            case I2F:
                opcode = 0x86;
                break;
            case I2D:
                opcode = 0x87;
                break;
            case L2I:
                opcode = 0x88;
                break;
            case L2F:
                opcode = 0x89;
                break;
            case L2D:
                opcode = 0x8A;
                break;
            case F2I:
                opcode = 0x8B;
                break;
            case F2L:
                opcode = 0x8C;
                break;
            case F2D:
                opcode = 0x8D;
                break;
            case D2I:
                opcode = 0x8E;
                break;
            case D2L:
                opcode = 0x8F;
                break;
            case D2F:
                opcode = 0x90;
                break;
            case I2B:
                opcode = 0x91;
                break;
            case I2C:
                opcode = 0x92;
                break;
            case I2S:
                opcode = 0x93;
                break;
            default:
                throw new IllegalStateException("Unknown unary op: " + instr.getOp());
        }
        emit(opcode);
    }

    private void emitGoto(GotoInstruction instr) throws IOException {
        // Skip goto if target is the next block (fall-through optimization)
        if (instr.getTarget() == nextBlock) {
            return;
        }
        emit(0xA7);
        pendingJumps.add(new PendingJump(currentOffset, instr.getTarget(), false));
        emitShort((short) 0);
    }

    private void emitBranch(BranchInstruction instr) throws IOException {
        int opcode;
        switch (instr.getCondition()) {
            case IFEQ:
                opcode = 0x99;
                break;
            case IFNE:
                opcode = 0x9A;
                break;
            case IFLT:
                opcode = 0x9B;
                break;
            case IFGE:
                opcode = 0x9C;
                break;
            case IFGT:
                opcode = 0x9D;
                break;
            case IFLE:
                opcode = 0x9E;
                break;
            case EQ:
                opcode = 0x9F;
                break;
            case NE:
                opcode = 0xA0;
                break;
            case LT:
                opcode = 0xA1;
                break;
            case GE:
                opcode = 0xA2;
                break;
            case GT:
                opcode = 0xA3;
                break;
            case LE:
                opcode = 0xA4;
                break;
            case ACMPEQ:
                opcode = 0xA5;
                break;
            case ACMPNE:
                opcode = 0xA6;
                break;
            case IFNULL:
                opcode = 0xC6;
                break;
            case IFNONNULL:
                opcode = 0xC7;
                break;
            default:
                throw new IllegalStateException("Unknown condition: " + instr.getCondition());
        }

        emit(opcode);
        pendingJumps.add(new PendingJump(currentOffset, instr.getTrueTarget(), false));
        emitShort((short) 0);

        // Skip false-branch goto if target is the next block (fall-through optimization)
        if (instr.getFalseTarget() != nextBlock) {
            emit(0xA7);
            pendingJumps.add(new PendingJump(currentOffset, instr.getFalseTarget(), false));
            emitShort((short) 0);
        }
    }

    private void emitReturn(ReturnInstruction instr) throws IOException {
        if (instr.isVoidReturn()) {
            emit(0xB1);
        } else {
            IRType type = instr.getReturnValue().getType();
            if (type instanceof PrimitiveType) {
                PrimitiveType prim = (PrimitiveType) type;
                int opcode;
                switch (prim) {
                    case INT:
                    case BOOLEAN:
                    case BYTE:
                    case CHAR:
                    case SHORT:
                        opcode = 0xAC;
                        break;
                    case LONG:
                        opcode = 0xAD;
                        break;
                    case FLOAT:
                        opcode = 0xAE;
                        break;
                    case DOUBLE:
                        opcode = 0xAF;
                        break;
                    default:
                        throw new IllegalStateException("Unknown primitive type: " + prim);
                }
                emit(opcode);
            } else {
                emit(0xB0);
            }
        }
    }

    private void emitInvoke(InvokeInstruction instr) throws IOException {
        int opcode;
        switch (instr.getInvokeType()) {
            case VIRTUAL:
                opcode = 0xB6;
                break;
            case SPECIAL:
                opcode = 0xB7;
                break;
            case STATIC:
                opcode = 0xB8;
                break;
            case INTERFACE:
                opcode = 0xB9;
                break;
            case DYNAMIC:
                opcode = 0xBA;
                break;
            default:
                throw new IllegalStateException("Unknown invoke type: " + instr.getInvokeType());
        }

        if (instr.getInvokeType() == InvokeType.DYNAMIC) {
            int cpIndex = instr.getOriginalCpIndex();
            if (cpIndex > 0) {
                emit(opcode);
                emitShort((short) cpIndex);
                emitShort((short) 0);
            } else {
                throw new UnsupportedOperationException(
                    "Cannot emit INVOKEDYNAMIC without original constant pool index. " +
                    "Method: " + instr.getName() + instr.getDescriptor());
            }
            return;
        }

        int cpIndex;
        if (instr.getInvokeType() == InvokeType.INTERFACE) {
            cpIndex = constPool.findOrAddInterfaceRef(
                    instr.getOwner(), instr.getName(), instr.getDescriptor()
            ).getIndex(constPool);
        } else {
            cpIndex = constPool.findOrAddMethodRef(
                    instr.getOwner(), instr.getName(), instr.getDescriptor()
            ).getIndex(constPool);
        }

        emit(opcode);
        emitShort((short) cpIndex);

        if (instr.getInvokeType() == InvokeType.INTERFACE) {
            emit((byte) (instr.getArguments().size() + 1));
            emit((byte) 0);
        }
    }

    private void emitGetField(GetFieldInstruction instr) throws IOException {
        int fieldRef = constPool.findOrAddFieldRef(
                instr.getOwner(), instr.getName(), instr.getDescriptor()
        ).getIndex(constPool);

        emit(instr.isStatic() ? 0xB2 : 0xB4);
        emitShort((short) fieldRef);
    }

    private void emitPutField(PutFieldInstruction instr) throws IOException {
        int fieldRef = constPool.findOrAddFieldRef(
                instr.getOwner(), instr.getName(), instr.getDescriptor()
        ).getIndex(constPool);

        emit(instr.isStatic() ? 0xB3 : 0xB5);
        emitShort((short) fieldRef);
    }

    private void emitNew(NewInstruction instr) throws IOException {
        int classRef = constPool.findOrAddClass(instr.getClassName()).getIndex(constPool);
        emit(0xBB);
        emitShort((short) classRef);
    }

    private void emitNewArray(NewArrayInstruction instr) throws IOException {
        IRType elemType = instr.getElementType();

        if (elemType instanceof PrimitiveType) {
            PrimitiveType prim = (PrimitiveType) elemType;
            emit(0xBC);
            int atype;
            switch (prim) {
                case BOOLEAN:
                    atype = 4;
                    break;
                case CHAR:
                    atype = 5;
                    break;
                case FLOAT:
                    atype = 6;
                    break;
                case DOUBLE:
                    atype = 7;
                    break;
                case BYTE:
                    atype = 8;
                    break;
                case SHORT:
                    atype = 9;
                    break;
                case INT:
                    atype = 10;
                    break;
                case LONG:
                    atype = 11;
                    break;
                default:
                    throw new IllegalStateException("Unknown primitive type: " + prim);
            }
            emit((byte) atype);
        } else if (instr.isMultiDimensional()) {
            String desc = instr.getResult().getType().getDescriptor();
            int classRef = constPool.findOrAddClass(desc).getIndex(constPool);
            emit(0xC5);
            emitShort((short) classRef);
            emit((byte) instr.getDimensions().size());
        } else {
            String className = elemType.getDescriptor();
            if (className.startsWith("L") && className.endsWith(";")) {
                className = className.substring(1, className.length() - 1);
            }
            int classRef = constPool.findOrAddClass(className).getIndex(constPool);
            emit(0xBD);
            emitShort((short) classRef);
        }
    }

    private void emitArrayLoad(ArrayLoadInstruction instr) throws IOException {
        IRType elemType = instr.getResult().getType();
        int opcode;
        if (elemType instanceof PrimitiveType) {
            PrimitiveType prim = (PrimitiveType) elemType;
            switch (prim) {
                case INT:
                    opcode = 0x2E;
                    break;
                case LONG:
                    opcode = 0x2F;
                    break;
                case FLOAT:
                    opcode = 0x30;
                    break;
                case DOUBLE:
                    opcode = 0x31;
                    break;
                case BYTE:
                case BOOLEAN:
                    opcode = 0x33;
                    break;
                case CHAR:
                    opcode = 0x34;
                    break;
                case SHORT:
                    opcode = 0x35;
                    break;
                default:
                    throw new IllegalStateException("Unknown primitive type: " + prim);
            }
        } else {
            opcode = 0x32;
        }
        emit(opcode);
    }

    private void emitArrayStore(ArrayStoreInstruction instr) throws IOException {
        IRType elemType = instr.getValue().getType();
        int opcode;
        if (elemType instanceof PrimitiveType) {
            PrimitiveType prim = (PrimitiveType) elemType;
            switch (prim) {
                case INT:
                    opcode = 0x4F;
                    break;
                case LONG:
                    opcode = 0x50;
                    break;
                case FLOAT:
                    opcode = 0x51;
                    break;
                case DOUBLE:
                    opcode = 0x52;
                    break;
                case BYTE:
                case BOOLEAN:
                    opcode = 0x54;
                    break;
                case CHAR:
                    opcode = 0x55;
                    break;
                case SHORT:
                    opcode = 0x56;
                    break;
                default:
                    throw new IllegalStateException("Unknown primitive type: " + prim);
            }
        } else {
            opcode = 0x53;
        }
        emit(opcode);
    }

    private void emitCast(CastInstruction instr) throws IOException {
        String typeName = instr.getTargetType().getDescriptor();
        if (typeName.startsWith("L") && typeName.endsWith(";")) {
            typeName = typeName.substring(1, typeName.length() - 1);
        }
        int classRef = constPool.findOrAddClass(typeName).getIndex(constPool);
        emit(0xC0);
        emitShort((short) classRef);
    }

    private void emitInstanceOf(InstanceOfInstruction instr) throws IOException {
        String typeName = instr.getCheckType().getDescriptor();
        if (typeName.startsWith("L") && typeName.endsWith(";")) {
            typeName = typeName.substring(1, typeName.length() - 1);
        }
        int classRef = constPool.findOrAddClass(typeName).getIndex(constPool);
        emit(0xC1);
        emitShort((short) classRef);
    }

    private void emitSwitch(SwitchInstruction instr) throws IOException {
        Map<Integer, IRBlock> cases = instr.getCases();
        List<Integer> keys = new ArrayList<>(cases.keySet());
        Collections.sort(keys);

        if (keys.isEmpty()) {
            emit(0xA7);
            pendingJumps.add(new PendingJump(currentOffset, instr.getDefaultTarget(), false));
            emitShort((short) 0);
            return;
        }

        int low = keys.get(0);
        int high = keys.get(keys.size() - 1);
        boolean useTableSwitch = (high - low + 1) <= keys.size() * 2;

        int switchStart = currentOffset;
        if (useTableSwitch) {
            emit(0xAA);
        } else {
            emit(0xAB);
        }

        while (currentOffset % 4 != 0) {
            emit(0);
        }

        pendingJumps.add(new PendingJump(currentOffset, instr.getDefaultTarget(), true));
        emitInt(0);

        if (useTableSwitch) {
            emitInt(low);
            emitInt(high);
            for (int key = low; key <= high; key++) {
                IRBlock target = cases.getOrDefault(key, instr.getDefaultTarget());
                pendingJumps.add(new PendingJump(currentOffset, target, true));
                emitInt(0);
            }
        } else {
            emitInt(keys.size());
            for (int key : keys) {
                emitInt(key);
                pendingJumps.add(new PendingJump(currentOffset, cases.get(key), true));
                emitInt(0);
            }
        }
    }

    /**
     * For phi copy values, returns the phi result's register slot.
     * Returns -1 if the value is not a phi copy.
     */
    private int getPhiCopyDestination(SSAValue copyValue) {
        Map<SSAValue, List<CopyInfo>> phiCopies = method.getPhiCopyMapping();
        if (phiCopies == null) return -1;

        for (Map.Entry<SSAValue, List<CopyInfo>> entry : phiCopies.entrySet()) {
            for (CopyInfo copyInfo : entry.getValue()) {
                if (copyInfo.copyValue().equals(copyValue)) {
                    // This is a phi copy - return the phi result's register
                    return regAlloc.getRegister(entry.getKey());
                }
            }
        }
        return -1;
    }

    private void emitCopy(CopyInstruction instr) throws IOException {
        Value source = instr.getSource();

        // For phi copies, the destination should be the phi result's slot, not the copy's slot
        int dstReg = getPhiCopyDestination(instr.getResult());
        if (dstReg < 0) {
            dstReg = regAlloc.getRegister(instr.getResult());
        }

        if (source instanceof SSAValue) {
            SSAValue ssa = (SSAValue) source;
            if (stackResidentValues.contains(ssa)) {
                IRType type = ssa.getType();
                if (type instanceof PrimitiveType) {
                    PrimitiveType prim = (PrimitiveType) type;
                    switch (prim) {
                        case INT:
                        case BOOLEAN:
                        case BYTE:
                        case CHAR:
                        case SHORT:
                            emitVarInsn(0x36, 0x3B, dstReg);
                            break;
                        case LONG:
                            emitVarInsn(0x37, 0x3F, dstReg);
                            break;
                        case FLOAT:
                            emitVarInsn(0x38, 0x43, dstReg);
                            break;
                        case DOUBLE:
                            emitVarInsn(0x39, 0x47, dstReg);
                            break;
                    }
                } else {
                    emitVarInsn(0x3A, 0x4B, dstReg);
                }
            } else {
                int srcReg = regAlloc.getRegister(ssa);
                if (srcReg != dstReg) {
                    IRType type = ssa.getType();
                    emitVarInsn(getLoadOpcode(type), getLoadShortBase(type), srcReg);
                    emitVarInsn(getStoreOpcode(type), getStoreShortBase(type), dstReg);
                }
            }
        } else if (source instanceof Constant) {
            Constant constant = (Constant) source;
            emitConstantValue(constant);
            IRType type = constant.getType();
            if (type instanceof PrimitiveType) {
                PrimitiveType prim = (PrimitiveType) type;
                switch (prim) {
                    case INT:
                    case BOOLEAN:
                    case BYTE:
                    case CHAR:
                    case SHORT:
                        emitVarInsn(0x36, 0x3B, dstReg);
                        break;
                    case LONG:
                        emitVarInsn(0x37, 0x3F, dstReg);
                        break;
                    case FLOAT:
                        emitVarInsn(0x38, 0x43, dstReg);
                        break;
                    case DOUBLE:
                        emitVarInsn(0x39, 0x47, dstReg);
                        break;
                }
            } else {
                emitVarInsn(0x3A, 0x4B, dstReg);
            }
        }
    }

    private int getLoadOpcode(IRType type) {
        if (type instanceof PrimitiveType) {
            PrimitiveType prim = (PrimitiveType) type;
            switch (prim) {
                case INT:
                case BOOLEAN:
                case BYTE:
                case CHAR:
                case SHORT:
                    return 0x15;
                case LONG:
                    return 0x16;
                case FLOAT:
                    return 0x17;
                case DOUBLE:
                    return 0x18;
            }
        }
        return 0x19;
    }

    private int getLoadShortBase(IRType type) {
        if (type instanceof PrimitiveType) {
            PrimitiveType prim = (PrimitiveType) type;
            switch (prim) {
                case INT:
                case BOOLEAN:
                case BYTE:
                case CHAR:
                case SHORT:
                    return 0x1A;
                case LONG:
                    return 0x1E;
                case FLOAT:
                    return 0x22;
                case DOUBLE:
                    return 0x26;
            }
        }
        return 0x2A;
    }

    private int getStoreOpcode(IRType type) {
        if (type instanceof PrimitiveType) {
            PrimitiveType prim = (PrimitiveType) type;
            switch (prim) {
                case INT:
                case BOOLEAN:
                case BYTE:
                case CHAR:
                case SHORT:
                    return 0x36;
                case LONG:
                    return 0x37;
                case FLOAT:
                    return 0x38;
                case DOUBLE:
                    return 0x39;
            }
        }
        return 0x3A;
    }

    private int getStoreShortBase(IRType type) {
        if (type instanceof PrimitiveType) {
            PrimitiveType prim = (PrimitiveType) type;
            switch (prim) {
                case INT:
                case BOOLEAN:
                case BYTE:
                case CHAR:
                case SHORT:
                    return 0x3B;
                case LONG:
                    return 0x3F;
                case FLOAT:
                    return 0x43;
                case DOUBLE:
                    return 0x47;
            }
        }
        return 0x4B;
    }

    private void fixupJumps() {
        byte[] code = bytecode.toByteArray();
        for (PendingJump jump : pendingJumps) {
            int targetOffset = blockOffsets.getOrDefault(jump.target(), 0);
            int opcodeOffset = jump.offset() - 1;
            int relativeOffset = targetOffset - opcodeOffset;

            if (jump.isWide()) {
                code[jump.offset()] = (byte) (relativeOffset >> 24);
                code[jump.offset() + 1] = (byte) (relativeOffset >> 16);
                code[jump.offset() + 2] = (byte) (relativeOffset >> 8);
                code[jump.offset() + 3] = (byte) relativeOffset;
            } else {
                // Check for overflow - offset must fit in signed 16-bit
                if (relativeOffset < Short.MIN_VALUE || relativeOffset > Short.MAX_VALUE) {
                    throw new IllegalStateException(
                        "Branch offset " + relativeOffset + " exceeds 16-bit range. " +
                        "Method is too large and requires wide branch instructions (goto_w).");
                }
                code[jump.offset()] = (byte) (relativeOffset >> 8);
                code[jump.offset() + 1] = (byte) relativeOffset;
            }
        }
        bytecode = new ByteArrayOutputStream();
        try {
            bytecode.write(code);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private void emit(int b) throws IOException {
        dos.writeByte(b);
        currentOffset++;
    }

    private void emitShort(short s) throws IOException {
        dos.writeShort(s);
        currentOffset += 2;
    }

    private void emitInt(int i) throws IOException {
        dos.writeInt(i);
        currentOffset += 4;
    }

    private static final class PendingJump {
        private final int offset;
        private final IRBlock target;
        private final boolean isWide;

        public PendingJump(int offset, IRBlock target, boolean isWide) {
            this.offset = offset;
            this.target = target;
            this.isWide = isWide;
        }

        public int offset() {
            return offset;
        }

        public IRBlock target() {
            return target;
        }

        public boolean isWide() {
            return isWide;
        }

        @Override
        public boolean equals(Object obj) {
            if (this == obj) return true;
            if (obj == null || getClass() != obj.getClass()) return false;
            PendingJump that = (PendingJump) obj;
            return offset == that.offset &&
                   isWide == that.isWide &&
                   Objects.equals(target, that.target);
        }

        @Override
        public int hashCode() {
            return Objects.hash(offset, target, isWide);
        }

        @Override
        public String toString() {
            return "PendingJump{" +
                   "offset=" + offset +
                   ", target=" + target +
                   ", isWide=" + isWide +
                   '}';
        }
    }
}
