package com.tonic.analysis.ssa.lower;

import com.tonic.analysis.ssa.cfg.IRBlock;
import com.tonic.analysis.ssa.cfg.IRMethod;
import com.tonic.analysis.ssa.ir.*;
import com.tonic.analysis.ssa.type.*;
import com.tonic.analysis.ssa.value.*;
import com.tonic.parser.ConstPool;
import lombok.Getter;

import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.util.*;

/**
 * Emits JVM bytecode from IR instructions.
 */
@Getter
public class BytecodeEmitter {

    private final IRMethod method;
    private final ConstPool constPool;
    private final RegisterAllocator regAlloc;
    private final StackScheduler scheduler;

    private ByteArrayOutputStream bytecode;
    private DataOutputStream dos;
    private Map<IRBlock, Integer> blockOffsets;
    private List<PendingJump> pendingJumps;
    private int currentOffset;

    private Set<SSAValue> stackResidentValues;

    // For fall-through optimization
    private IRBlock nextBlock;

    /**
     * Creates a new bytecode emitter.
     *
     * @param method the IR method to emit
     * @param constPool the constant pool
     * @param regAlloc the register allocator
     * @param scheduler the stack scheduler
     */
    public BytecodeEmitter(IRMethod method, ConstPool constPool, RegisterAllocator regAlloc, StackScheduler scheduler) {
        this.method = method;
        this.constPool = constPool;
        this.regAlloc = regAlloc;
        this.scheduler = scheduler;
        this.blockOffsets = new HashMap<>();
        this.pendingJumps = new ArrayList<>();
        this.stackResidentValues = new HashSet<>();
    }

    /**
     * Emits bytecode for the IR method.
     *
     * @return the generated bytecode
     */
    public byte[] emit() {
        bytecode = new ByteArrayOutputStream();
        dos = new DataOutputStream(bytecode);
        currentOffset = 0;

        analyzeStackResidentValues();

        try {
            List<IRBlock> orderedBlocks = computeOptimalBlockOrder();
            for (int i = 0; i < orderedBlocks.size(); i++) {
                IRBlock block = orderedBlocks.get(i);
                // Track what block comes next for fall-through optimization
                nextBlock = (i + 1 < orderedBlocks.size()) ? orderedBlocks.get(i + 1) : null;
                emitBlock(block);
            }
            fixupJumps();
        } catch (IOException e) {
            throw new RuntimeException("Failed to emit bytecode", e);
        }

        return bytecode.toByteArray();
    }

    /**
     * Computes an optimal block ordering that maximizes fall-through opportunities.
     * Uses a greedy algorithm that places fall-through successors immediately after their predecessors.
     */
    private List<IRBlock> computeOptimalBlockOrder() {
        List<IRBlock> order = new ArrayList<>();
        Set<IRBlock> placed = new HashSet<>();
        Deque<IRBlock> worklist = new ArrayDeque<>();

        IRBlock entry = method.getEntryBlock();
        if (entry == null) {
            return method.getBlocksInOrder(); // Fallback to original order
        }

        worklist.add(entry);

        while (!worklist.isEmpty()) {
            IRBlock block = worklist.pollFirst();
            if (placed.contains(block)) continue;

            placed.add(block);
            order.add(block);

            // Determine preferred fall-through successor
            IRBlock fallThrough = getFallThroughSuccessor(block);

            // Add fall-through first (will be processed next)
            if (fallThrough != null && !placed.contains(fallThrough)) {
                worklist.addFirst(fallThrough);
            }

            // Add other successors to back of queue
            for (IRBlock succ : block.getSuccessors()) {
                if (!placed.contains(succ)) {
                    worklist.addLast(succ);
                }
            }
        }

        // Add any remaining blocks (shouldn't happen with well-formed CFG)
        for (IRBlock block : method.getBlocks()) {
            if (!placed.contains(block)) {
                order.add(block);
            }
        }

        return order;
    }

    /**
     * Determines the preferred fall-through successor for a block.
     * For branches, prefers the false target as fall-through.
     * For gotos, the only successor is the fall-through candidate.
     */
    private IRBlock getFallThroughSuccessor(IRBlock block) {
        IRInstruction term = block.getTerminator();
        if (term instanceof BranchInstruction branch) {
            // Prefer false branch as fall-through (allows skipping the goto)
            return branch.getFalseTarget();
        }
        if (term instanceof GotoInstruction gotoInstr) {
            // Goto's target is the only successor - prefer it as fall-through
            return gotoInstr.getTarget();
        }
        return null;
    }

    /**
     * Identifies values that can remain on the stack instead of being stored to a register.
     */
    private void analyzeStackResidentValues() {
        stackResidentValues.clear();

        Map<SSAValue, Integer> useCounts = new HashMap<>();
        for (IRBlock block : method.getBlocksInOrder()) {
            for (IRInstruction instr : block.getInstructions()) {
                for (Value operand : instr.getOperands()) {
                    if (operand instanceof SSAValue ssa) {
                        useCounts.merge(ssa, 1, Integer::sum);
                    }
                }
            }
        }

        for (IRBlock block : method.getBlocksInOrder()) {
            List<IRInstruction> instructions = block.getInstructions();

            for (int i = 0; i < instructions.size() - 1; i++) {
                IRInstruction current = instructions.get(i);
                IRInstruction next = instructions.get(i + 1);

                if (!current.hasResult()) continue;
                SSAValue result = current.getResult();
                if (result == null) continue;

                int useCount = useCounts.getOrDefault(result, 0);
                if (useCount != 1) continue;

                List<Value> nextOperands = next.getOperands();
                if (nextOperands.isEmpty()) continue;

                if (nextOperands.get(0).equals(result)) {
                    if (nextOperands.size() == 1 || isSimpleOperand(nextOperands.get(1))) {
                        stackResidentValues.add(result);
                    }
                }
                else if (nextOperands.size() == 1 && nextOperands.get(0).equals(result)) {
                    stackResidentValues.add(result);
                }
            }
        }
    }

    private boolean isSimpleOperand(Value operand) {
        if (operand instanceof Constant) return true;
        if (operand instanceof SSAValue ssa) {
            String name = ssa.getName();
            return name.startsWith("p") || name.equals("this");
        }
        return false;
    }

    private void emitBlock(IRBlock block) throws IOException {
        blockOffsets.put(block, currentOffset);

        for (IRInstruction instr : block.getInstructions()) {
            emitInstruction(instr);
        }
    }

    private void emitInstruction(IRInstruction instr) throws IOException {
        emitOperandLoads(instr);

        if (instr instanceof ConstantInstruction constInstr) {
            emitConstant(constInstr);
        } else if (instr instanceof LoadLocalInstruction load) {
            emitLoad(load);
        } else if (instr instanceof StoreLocalInstruction) {
        } else if (instr instanceof BinaryOpInstruction binOp) {
            emitBinaryOp(binOp);
        } else if (instr instanceof UnaryOpInstruction unaryOp) {
            emitUnaryOp(unaryOp);
        } else if (instr instanceof GotoInstruction gotoInstr) {
            emitGoto(gotoInstr);
        } else if (instr instanceof BranchInstruction branch) {
            emitBranch(branch);
        } else if (instr instanceof ReturnInstruction ret) {
            emitReturn(ret);
        } else if (instr instanceof InvokeInstruction invoke) {
            emitInvoke(invoke);
        } else if (instr instanceof GetFieldInstruction getField) {
            emitGetField(getField);
        } else if (instr instanceof PutFieldInstruction putField) {
            emitPutField(putField);
        } else if (instr instanceof NewInstruction newInstr) {
            emitNew(newInstr);
        } else if (instr instanceof NewArrayInstruction newArray) {
            emitNewArray(newArray);
        } else if (instr instanceof ArrayLoadInstruction arrayLoad) {
            emitArrayLoad(arrayLoad);
        } else if (instr instanceof ArrayStoreInstruction arrayStore) {
            emitArrayStore(arrayStore);
        } else if (instr instanceof ArrayLengthInstruction) {
            emit(0xBE);
        } else if (instr instanceof ThrowInstruction) {
            emit(0xBF);
        } else if (instr instanceof CastInstruction cast) {
            emitCast(cast);
        } else if (instr instanceof InstanceOfInstruction instanceOf) {
            emitInstanceOf(instanceOf);
        } else if (instr instanceof MonitorEnterInstruction) {
            emit(0xC2);
        } else if (instr instanceof MonitorExitInstruction) {
            emit(0xC3);
        } else if (instr instanceof SwitchInstruction switchInstr) {
            emitSwitch(switchInstr);
        } else if (instr instanceof CopyInstruction copy) {
            emitCopy(copy);
        }

        emitResultStore(instr);
    }

    private void emitOperandLoads(IRInstruction instr) throws IOException {
        if (instr instanceof ConstantInstruction ||
            instr instanceof LoadLocalInstruction ||
            instr instanceof StoreLocalInstruction ||
            instr instanceof GotoInstruction ||
            instr instanceof CopyInstruction) {
            return;
        }

        for (Value operand : instr.getOperands()) {
            if (operand instanceof SSAValue ssa) {
                if (stackResidentValues.contains(ssa)) {
                    continue;
                }
                emitLoadValue(ssa);
            } else if (operand instanceof Constant) {
                emitConstantValue((Constant) operand);
            }
        }
    }

    private void emitLoadValue(SSAValue value) throws IOException {
        int reg = regAlloc.getRegister(value);
        if (reg < 0) {
            throw new IllegalStateException("No register allocated for value: " + value + " (name=" + value.getName() + ")");
        }
        IRType type = value.getType();

        if (type instanceof PrimitiveType prim) {
            switch (prim) {
                case INT, BOOLEAN, BYTE, CHAR, SHORT -> emitVarInsn(0x15, 0x1A, reg);
                case LONG -> emitVarInsn(0x16, 0x1E, reg);
                case FLOAT -> emitVarInsn(0x17, 0x22, reg);
                case DOUBLE -> emitVarInsn(0x18, 0x26, reg);
            }
        } else {
            emitVarInsn(0x19, 0x2A, reg);
        }
    }

    private void emitConstantValue(Constant constant) throws IOException {
        if (constant instanceof IntConstant intConst) {
            int value = intConst.getValue();
            if (value >= -1 && value <= 5) {
                emit(0x03 + value);
            } else if (value >= Byte.MIN_VALUE && value <= Byte.MAX_VALUE) {
                emit(0x10);
                emit((byte) value);
            } else if (value >= Short.MIN_VALUE && value <= Short.MAX_VALUE) {
                emit(0x11);
                emitShort((short) value);
            } else {
                int index = constPool.findOrAddInteger(value).getIndex(constPool);
                emitLdc(index);
            }
        } else if (constant instanceof LongConstant longConst) {
            long value = longConst.getValue();
            if (value == 0L) emit(0x09);
            else if (value == 1L) emit(0x0A);
            else {
                int index = constPool.findOrAddLong(value).getIndex(constPool);
                emit(0x14);
                emitShort((short) index);
            }
        } else if (constant instanceof FloatConstant floatConst) {
            float value = floatConst.getValue();
            if (value == 0.0f) emit(0x0B);
            else if (value == 1.0f) emit(0x0C);
            else if (value == 2.0f) emit(0x0D);
            else {
                int index = constPool.findOrAddFloat(value).getIndex(constPool);
                emitLdc(index);
            }
        } else if (constant instanceof DoubleConstant doubleConst) {
            double value = doubleConst.getValue();
            if (value == 0.0) emit(0x0E);
            else if (value == 1.0) emit(0x0F);
            else {
                int index = constPool.findOrAddDouble(value).getIndex(constPool);
                emit(0x14);
                emitShort((short) index);
            }
        } else if (constant instanceof StringConstant stringConst) {
            int index = constPool.findOrAddString(stringConst.getValue()).getIndex(constPool);
            emitLdc(index);
        } else if (constant instanceof NullConstant) {
            emit(0x01);
        } else if (constant instanceof ClassConstant classConst) {
            int index = constPool.findOrAddClass(classConst.getClassName()).getIndex(constPool);
            emitLdc(index);
        }
    }

    private void emitResultStore(IRInstruction instr) throws IOException {
        if (!instr.hasResult()) return;
        SSAValue result = instr.getResult();
        if (result == null) return;

        if (instr instanceof CopyInstruction ||
            instr instanceof LoadLocalInstruction ||
            instr instanceof StoreLocalInstruction) {
            return;
        }

        if (stackResidentValues.contains(result)) {
            return;
        }

        int reg = regAlloc.getRegister(result);
        IRType type = result.getType();

        if (type instanceof PrimitiveType prim) {
            switch (prim) {
                case INT, BOOLEAN, BYTE, CHAR, SHORT -> emitVarInsn(0x36, 0x3B, reg);
                case LONG -> emitVarInsn(0x37, 0x3F, reg);
                case FLOAT -> emitVarInsn(0x38, 0x43, reg);
                case DOUBLE -> emitVarInsn(0x39, 0x47, reg);
            }
        } else {
            emitVarInsn(0x3A, 0x4B, reg);
        }
    }

    private void emitConstant(ConstantInstruction instr) throws IOException {
        Constant constant = instr.getConstant();

        if (constant instanceof IntConstant intConst) {
            int value = intConst.getValue();
            if (value >= -1 && value <= 5) {
                emit(0x03 + value);
            } else if (value >= Byte.MIN_VALUE && value <= Byte.MAX_VALUE) {
                emit(0x10);
                emit((byte) value);
            } else if (value >= Short.MIN_VALUE && value <= Short.MAX_VALUE) {
                emit(0x11);
                emitShort((short) value);
            } else {
                int index = constPool.findOrAddInteger(value).getIndex(constPool);
                emitLdc(index);
            }
        } else if (constant instanceof LongConstant longConst) {
            long value = longConst.getValue();
            if (value == 0L) {
                emit(0x09);
            } else if (value == 1L) {
                emit(0x0A);
            } else {
                int index = constPool.findOrAddLong(value).getIndex(constPool);
                emit(0x14);
                emitShort((short) index);
            }
        } else if (constant instanceof FloatConstant floatConst) {
            float value = floatConst.getValue();
            if (value == 0.0f) {
                emit(0x0B);
            } else if (value == 1.0f) {
                emit(0x0C);
            } else if (value == 2.0f) {
                emit(0x0D);
            } else {
                int index = constPool.findOrAddFloat(value).getIndex(constPool);
                emitLdc(index);
            }
        } else if (constant instanceof DoubleConstant doubleConst) {
            double value = doubleConst.getValue();
            if (value == 0.0) {
                emit(0x0E);
            } else if (value == 1.0) {
                emit(0x0F);
            } else {
                int index = constPool.findOrAddDouble(value).getIndex(constPool);
                emit(0x14);
                emitShort((short) index);
            }
        } else if (constant instanceof StringConstant stringConst) {
            int index = constPool.findOrAddString(stringConst.getValue()).getIndex(constPool);
            emitLdc(index);
        } else if (constant instanceof NullConstant) {
            emit(0x01);
        } else if (constant instanceof ClassConstant classConst) {
            int index = constPool.findOrAddClass(classConst.getClassName()).getIndex(constPool);
            emitLdc(index);
        } else if (constant instanceof MethodHandleConstant mhConst) {
            int index = constPool.findOrAddMethodHandle(
                    mhConst.getReferenceKind(),
                    mhConst.getOwner(),
                    mhConst.getName(),
                    mhConst.getDescriptor()
            ).getIndex(constPool);
            emitLdc(index);
        } else if (constant instanceof MethodTypeConstant mtConst) {
            int index = constPool.findOrAddMethodType(mtConst.getDescriptor()).getIndex(constPool);
            emitLdc(index);
        } else if (constant instanceof DynamicConstant dynConst) {
            // For condy, use original CP index if available (roundtrip preservation)
            int cpIndex = dynConst.getOriginalCpIndex();
            if (cpIndex > 0) {
                if (dynConst.getType().isTwoSlot()) {
                    emit(0x14); // ldc2_w
                    emitShort((short) cpIndex);
                } else {
                    emitLdc(cpIndex);
                }
            } else {
                throw new UnsupportedOperationException(
                        "Cannot emit DynamicConstant without original constant pool index. " +
                        "Dynamic: " + dynConst.getName() + ":" + dynConst.getDescriptor());
            }
        }
    }

    private void emitLdc(int index) throws IOException {
        if (index <= 255) {
            emit(0x12);
            emit((byte) index);
        } else {
            emit(0x13);
            emitShort((short) index);
        }
    }

    private void emitLoad(LoadLocalInstruction instr) throws IOException {
        // Use the RegisterAllocator's slot for the result value, not the original local index.
        // The original local index may be stale after transformations like method inlining.
        SSAValue result = instr.getResult();
        int index = regAlloc.getRegister(result);
        if (index < 0) {
            // No register allocation for this result - it was likely replaced by replaceAllUsesWith
            // during inlining. Skip emitting this instruction entirely.
            // The value has been replaced with another SSAValue that will be loaded when needed.
            return;
        }
        IRType type = result.getType();

        if (type instanceof PrimitiveType prim) {
            switch (prim) {
                case INT, BOOLEAN, BYTE, CHAR, SHORT -> emitVarInsn(0x15, 0x1A, index);
                case LONG -> emitVarInsn(0x16, 0x1E, index);
                case FLOAT -> emitVarInsn(0x17, 0x22, index);
                case DOUBLE -> emitVarInsn(0x18, 0x26, index);
            }
        } else {
            emitVarInsn(0x19, 0x2A, index);
        }
    }

    private void emitStore(StoreLocalInstruction instr) throws IOException {
        // For StoreLocal, we need to determine the destination slot.
        // The original local index may be stale after transformations like method inlining.
        // Try to use the allocator's slot for the value being stored.
        Value value = instr.getValue();
        int index = instr.getLocalIndex();
        if (value instanceof SSAValue ssa) {
            int allocIndex = regAlloc.getRegister(ssa);
            if (allocIndex >= 0) {
                index = allocIndex;
            }
        }
        IRType type = value.getType();

        if (type instanceof PrimitiveType prim) {
            switch (prim) {
                case INT, BOOLEAN, BYTE, CHAR, SHORT -> emitVarInsn(0x36, 0x3B, index);
                case LONG -> emitVarInsn(0x37, 0x3F, index);
                case FLOAT -> emitVarInsn(0x38, 0x43, index);
                case DOUBLE -> emitVarInsn(0x39, 0x47, index);
            }
        } else {
            emitVarInsn(0x3A, 0x4B, index);
        }
    }

    private void emitVarInsn(int wideOp, int shortOpBase, int index) throws IOException {
        if (index <= 3) {
            emit(shortOpBase + index);
        } else if (index <= 255) {
            emit(wideOp);
            emit((byte) index);
        } else {
            emit(0xC4);
            emit(wideOp);
            emitShort((short) index);
        }
    }

    private void emitBinaryOp(BinaryOpInstruction instr) throws IOException {
        IRType type = instr.getResult().getType();
        int baseOpcode = getBinaryOpcode(instr.getOp(), type);
        emit(baseOpcode);
    }

    private int getBinaryOpcode(BinaryOp op, IRType type) {
        int typeOffset = getTypeOffset(type);
        return switch (op) {
            case ADD -> 0x60 + typeOffset;
            case SUB -> 0x64 + typeOffset;
            case MUL -> 0x68 + typeOffset;
            case DIV -> 0x6C + typeOffset;
            case REM -> 0x70 + typeOffset;
            case SHL -> type == PrimitiveType.LONG ? 0x79 : 0x78;
            case SHR -> type == PrimitiveType.LONG ? 0x7B : 0x7A;
            case USHR -> type == PrimitiveType.LONG ? 0x7D : 0x7C;
            case AND -> type == PrimitiveType.LONG ? 0x7F : 0x7E;
            case OR -> type == PrimitiveType.LONG ? 0x81 : 0x80;
            case XOR -> type == PrimitiveType.LONG ? 0x83 : 0x82;
            case LCMP -> 0x94;
            case FCMPL -> 0x95;
            case FCMPG -> 0x96;
            case DCMPL -> 0x97;
            case DCMPG -> 0x98;
        };
    }

    private int getTypeOffset(IRType type) {
        if (type == PrimitiveType.INT) return 0;
        if (type == PrimitiveType.LONG) return 1;
        if (type == PrimitiveType.FLOAT) return 2;
        if (type == PrimitiveType.DOUBLE) return 3;
        return 0;
    }

    private void emitUnaryOp(UnaryOpInstruction instr) throws IOException {
        int opcode = switch (instr.getOp()) {
            case NEG -> {
                IRType type = instr.getOperand().getType();
                yield 0x74 + getTypeOffset(type);
            }
            case I2L -> 0x85;
            case I2F -> 0x86;
            case I2D -> 0x87;
            case L2I -> 0x88;
            case L2F -> 0x89;
            case L2D -> 0x8A;
            case F2I -> 0x8B;
            case F2L -> 0x8C;
            case F2D -> 0x8D;
            case D2I -> 0x8E;
            case D2L -> 0x8F;
            case D2F -> 0x90;
            case I2B -> 0x91;
            case I2C -> 0x92;
            case I2S -> 0x93;
        };
        emit(opcode);
    }

    private void emitGoto(GotoInstruction instr) throws IOException {
        // Skip goto if target is the next block (fall-through optimization)
        if (instr.getTarget() == nextBlock) {
            return;
        }
        emit(0xA7);
        pendingJumps.add(new PendingJump(currentOffset, instr.getTarget(), false));
        emitShort((short) 0);
    }

    private void emitBranch(BranchInstruction instr) throws IOException {
        int opcode = switch (instr.getCondition()) {
            case IFEQ -> 0x99;
            case IFNE -> 0x9A;
            case IFLT -> 0x9B;
            case IFGE -> 0x9C;
            case IFGT -> 0x9D;
            case IFLE -> 0x9E;
            case EQ -> 0x9F;
            case NE -> 0xA0;
            case LT -> 0xA1;
            case GE -> 0xA2;
            case GT -> 0xA3;
            case LE -> 0xA4;
            case ACMPEQ -> 0xA5;
            case ACMPNE -> 0xA6;
            case IFNULL -> 0xC6;
            case IFNONNULL -> 0xC7;
        };

        emit(opcode);
        pendingJumps.add(new PendingJump(currentOffset, instr.getTrueTarget(), false));
        emitShort((short) 0);

        // Skip false-branch goto if target is the next block (fall-through optimization)
        if (instr.getFalseTarget() != nextBlock) {
            emit(0xA7);
            pendingJumps.add(new PendingJump(currentOffset, instr.getFalseTarget(), false));
            emitShort((short) 0);
        }
    }

    private void emitReturn(ReturnInstruction instr) throws IOException {
        if (instr.isVoidReturn()) {
            emit(0xB1);
        } else {
            IRType type = instr.getReturnValue().getType();
            if (type instanceof PrimitiveType prim) {
                int opcode = switch (prim) {
                    case INT, BOOLEAN, BYTE, CHAR, SHORT -> 0xAC;
                    case LONG -> 0xAD;
                    case FLOAT -> 0xAE;
                    case DOUBLE -> 0xAF;
                };
                emit(opcode);
            } else {
                emit(0xB0);
            }
        }
    }

    private void emitInvoke(InvokeInstruction instr) throws IOException {
        int opcode = switch (instr.getInvokeType()) {
            case VIRTUAL -> 0xB6;
            case SPECIAL -> 0xB7;
            case STATIC -> 0xB8;
            case INTERFACE -> 0xB9;
            case DYNAMIC -> 0xBA;
        };

        if (instr.getInvokeType() == InvokeType.DYNAMIC) {
            int cpIndex = instr.getOriginalCpIndex();
            if (cpIndex > 0) {
                emit(opcode);
                emitShort((short) cpIndex);
                emitShort((short) 0);
            } else {
                throw new UnsupportedOperationException(
                    "Cannot emit INVOKEDYNAMIC without original constant pool index. " +
                    "Method: " + instr.getName() + instr.getDescriptor());
            }
            return;
        }

        int cpIndex;
        if (instr.getInvokeType() == InvokeType.INTERFACE) {
            cpIndex = constPool.findOrAddInterfaceRef(
                    instr.getOwner(), instr.getName(), instr.getDescriptor()
            ).getIndex(constPool);
        } else {
            cpIndex = constPool.findOrAddMethodRef(
                    instr.getOwner(), instr.getName(), instr.getDescriptor()
            ).getIndex(constPool);
        }

        emit(opcode);
        emitShort((short) cpIndex);

        if (instr.getInvokeType() == InvokeType.INTERFACE) {
            emit((byte) (instr.getArguments().size() + 1));
            emit((byte) 0);
        }
    }

    private void emitGetField(GetFieldInstruction instr) throws IOException {
        int fieldRef = constPool.findOrAddFieldRef(
                instr.getOwner(), instr.getName(), instr.getDescriptor()
        ).getIndex(constPool);

        emit(instr.isStatic() ? 0xB2 : 0xB4);
        emitShort((short) fieldRef);
    }

    private void emitPutField(PutFieldInstruction instr) throws IOException {
        int fieldRef = constPool.findOrAddFieldRef(
                instr.getOwner(), instr.getName(), instr.getDescriptor()
        ).getIndex(constPool);

        emit(instr.isStatic() ? 0xB3 : 0xB5);
        emitShort((short) fieldRef);
    }

    private void emitNew(NewInstruction instr) throws IOException {
        int classRef = constPool.findOrAddClass(instr.getClassName()).getIndex(constPool);
        emit(0xBB);
        emitShort((short) classRef);
    }

    private void emitNewArray(NewArrayInstruction instr) throws IOException {
        IRType elemType = instr.getElementType();

        if (elemType instanceof PrimitiveType prim) {
            emit(0xBC);
            int atype = switch (prim) {
                case BOOLEAN -> 4;
                case CHAR -> 5;
                case FLOAT -> 6;
                case DOUBLE -> 7;
                case BYTE -> 8;
                case SHORT -> 9;
                case INT -> 10;
                case LONG -> 11;
            };
            emit((byte) atype);
        } else if (instr.isMultiDimensional()) {
            String desc = instr.getResult().getType().getDescriptor();
            int classRef = constPool.findOrAddClass(desc).getIndex(constPool);
            emit(0xC5);
            emitShort((short) classRef);
            emit((byte) instr.getDimensions().size());
        } else {
            String className = elemType.getDescriptor();
            if (className.startsWith("L") && className.endsWith(";")) {
                className = className.substring(1, className.length() - 1);
            }
            int classRef = constPool.findOrAddClass(className).getIndex(constPool);
            emit(0xBD);
            emitShort((short) classRef);
        }
    }

    private void emitArrayLoad(ArrayLoadInstruction instr) throws IOException {
        IRType elemType = instr.getResult().getType();
        int opcode;
        if (elemType instanceof PrimitiveType prim) {
            opcode = switch (prim) {
                case INT -> 0x2E;
                case LONG -> 0x2F;
                case FLOAT -> 0x30;
                case DOUBLE -> 0x31;
                case BYTE, BOOLEAN -> 0x33;
                case CHAR -> 0x34;
                case SHORT -> 0x35;
            };
        } else {
            opcode = 0x32;
        }
        emit(opcode);
    }

    private void emitArrayStore(ArrayStoreInstruction instr) throws IOException {
        IRType elemType = instr.getValue().getType();
        int opcode;
        if (elemType instanceof PrimitiveType prim) {
            opcode = switch (prim) {
                case INT -> 0x4F;
                case LONG -> 0x50;
                case FLOAT -> 0x51;
                case DOUBLE -> 0x52;
                case BYTE, BOOLEAN -> 0x54;
                case CHAR -> 0x55;
                case SHORT -> 0x56;
            };
        } else {
            opcode = 0x53;
        }
        emit(opcode);
    }

    private void emitCast(CastInstruction instr) throws IOException {
        String typeName = instr.getTargetType().getDescriptor();
        if (typeName.startsWith("L") && typeName.endsWith(";")) {
            typeName = typeName.substring(1, typeName.length() - 1);
        }
        int classRef = constPool.findOrAddClass(typeName).getIndex(constPool);
        emit(0xC0);
        emitShort((short) classRef);
    }

    private void emitInstanceOf(InstanceOfInstruction instr) throws IOException {
        String typeName = instr.getCheckType().getDescriptor();
        if (typeName.startsWith("L") && typeName.endsWith(";")) {
            typeName = typeName.substring(1, typeName.length() - 1);
        }
        int classRef = constPool.findOrAddClass(typeName).getIndex(constPool);
        emit(0xC1);
        emitShort((short) classRef);
    }

    private void emitSwitch(SwitchInstruction instr) throws IOException {
        Map<Integer, IRBlock> cases = instr.getCases();
        List<Integer> keys = new ArrayList<>(cases.keySet());
        Collections.sort(keys);

        if (keys.isEmpty()) {
            emit(0xA7);
            pendingJumps.add(new PendingJump(currentOffset, instr.getDefaultTarget(), false));
            emitShort((short) 0);
            return;
        }

        int low = keys.get(0);
        int high = keys.get(keys.size() - 1);
        boolean useTableSwitch = (high - low + 1) <= keys.size() * 2;

        int switchStart = currentOffset;
        if (useTableSwitch) {
            emit(0xAA);
        } else {
            emit(0xAB);
        }

        while (currentOffset % 4 != 0) {
            emit(0);
        }

        pendingJumps.add(new PendingJump(currentOffset, instr.getDefaultTarget(), true));
        emitInt(0);

        if (useTableSwitch) {
            emitInt(low);
            emitInt(high);
            for (int key = low; key <= high; key++) {
                IRBlock target = cases.getOrDefault(key, instr.getDefaultTarget());
                pendingJumps.add(new PendingJump(currentOffset, target, true));
                emitInt(0);
            }
        } else {
            emitInt(keys.size());
            for (int key : keys) {
                emitInt(key);
                pendingJumps.add(new PendingJump(currentOffset, cases.get(key), true));
                emitInt(0);
            }
        }
    }

    /**
     * For phi copy values, returns the phi result's register slot.
     * Returns -1 if the value is not a phi copy.
     */
    private int getPhiCopyDestination(SSAValue copyValue) {
        Map<SSAValue, List<CopyInfo>> phiCopies = method.getPhiCopyMapping();
        if (phiCopies == null) return -1;

        for (Map.Entry<SSAValue, List<CopyInfo>> entry : phiCopies.entrySet()) {
            for (CopyInfo copyInfo : entry.getValue()) {
                if (copyInfo.copyValue().equals(copyValue)) {
                    // This is a phi copy - return the phi result's register
                    return regAlloc.getRegister(entry.getKey());
                }
            }
        }
        return -1;
    }

    private void emitCopy(CopyInstruction instr) throws IOException {
        Value source = instr.getSource();

        // For phi copies, the destination should be the phi result's slot, not the copy's slot
        int dstReg = getPhiCopyDestination(instr.getResult());
        if (dstReg < 0) {
            dstReg = regAlloc.getRegister(instr.getResult());
        }

        if (source instanceof SSAValue ssa) {
            if (stackResidentValues.contains(ssa)) {
                IRType type = ssa.getType();
                if (type instanceof PrimitiveType prim) {
                    switch (prim) {
                        case INT, BOOLEAN, BYTE, CHAR, SHORT -> emitVarInsn(0x36, 0x3B, dstReg);
                        case LONG -> emitVarInsn(0x37, 0x3F, dstReg);
                        case FLOAT -> emitVarInsn(0x38, 0x43, dstReg);
                        case DOUBLE -> emitVarInsn(0x39, 0x47, dstReg);
                    }
                } else {
                    emitVarInsn(0x3A, 0x4B, dstReg);
                }
            } else {
                int srcReg = regAlloc.getRegister(ssa);
                if (srcReg != dstReg) {
                    IRType type = ssa.getType();
                    emitVarInsn(getLoadOpcode(type), getLoadShortBase(type), srcReg);
                    emitVarInsn(getStoreOpcode(type), getStoreShortBase(type), dstReg);
                }
            }
        } else if (source instanceof Constant constant) {
            emitConstantValue(constant);
            IRType type = constant.getType();
            if (type instanceof PrimitiveType prim) {
                switch (prim) {
                    case INT, BOOLEAN, BYTE, CHAR, SHORT -> emitVarInsn(0x36, 0x3B, dstReg);
                    case LONG -> emitVarInsn(0x37, 0x3F, dstReg);
                    case FLOAT -> emitVarInsn(0x38, 0x43, dstReg);
                    case DOUBLE -> emitVarInsn(0x39, 0x47, dstReg);
                }
            } else {
                emitVarInsn(0x3A, 0x4B, dstReg);
            }
        }
    }

    private int getLoadOpcode(IRType type) {
        if (type instanceof PrimitiveType prim) {
            return switch (prim) {
                case INT, BOOLEAN, BYTE, CHAR, SHORT -> 0x15;
                case LONG -> 0x16;
                case FLOAT -> 0x17;
                case DOUBLE -> 0x18;
            };
        }
        return 0x19;
    }

    private int getLoadShortBase(IRType type) {
        if (type instanceof PrimitiveType prim) {
            return switch (prim) {
                case INT, BOOLEAN, BYTE, CHAR, SHORT -> 0x1A;
                case LONG -> 0x1E;
                case FLOAT -> 0x22;
                case DOUBLE -> 0x26;
            };
        }
        return 0x2A;
    }

    private int getStoreOpcode(IRType type) {
        if (type instanceof PrimitiveType prim) {
            return switch (prim) {
                case INT, BOOLEAN, BYTE, CHAR, SHORT -> 0x36;
                case LONG -> 0x37;
                case FLOAT -> 0x38;
                case DOUBLE -> 0x39;
            };
        }
        return 0x3A;
    }

    private int getStoreShortBase(IRType type) {
        if (type instanceof PrimitiveType prim) {
            return switch (prim) {
                case INT, BOOLEAN, BYTE, CHAR, SHORT -> 0x3B;
                case LONG -> 0x3F;
                case FLOAT -> 0x43;
                case DOUBLE -> 0x47;
            };
        }
        return 0x4B;
    }

    private void fixupJumps() {
        byte[] code = bytecode.toByteArray();
        for (PendingJump jump : pendingJumps) {
            int targetOffset = blockOffsets.getOrDefault(jump.target, 0);
            int opcodeOffset = jump.offset - 1;
            int relativeOffset = targetOffset - opcodeOffset;

            if (jump.isWide) {
                code[jump.offset] = (byte) (relativeOffset >> 24);
                code[jump.offset + 1] = (byte) (relativeOffset >> 16);
                code[jump.offset + 2] = (byte) (relativeOffset >> 8);
                code[jump.offset + 3] = (byte) relativeOffset;
            } else {
                // Check for overflow - offset must fit in signed 16-bit
                if (relativeOffset < Short.MIN_VALUE || relativeOffset > Short.MAX_VALUE) {
                    throw new IllegalStateException(
                        "Branch offset " + relativeOffset + " exceeds 16-bit range. " +
                        "Method is too large and requires wide branch instructions (goto_w).");
                }
                code[jump.offset] = (byte) (relativeOffset >> 8);
                code[jump.offset + 1] = (byte) relativeOffset;
            }
        }
        bytecode = new ByteArrayOutputStream();
        try {
            bytecode.write(code);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private void emit(int b) throws IOException {
        dos.writeByte(b);
        currentOffset++;
    }

    private void emitShort(short s) throws IOException {
        dos.writeShort(s);
        currentOffset += 2;
    }

    private void emitInt(int i) throws IOException {
        dos.writeInt(i);
        currentOffset += 4;
    }

    private record PendingJump(int offset, IRBlock target, boolean isWide) {}
}
